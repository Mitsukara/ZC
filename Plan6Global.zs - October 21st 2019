//Updated October 20th 2019






// ----------------------------------------------------------------------------
// ---------------------------------------------- Index (ctrl+F to find these):
// ----------------------------------------------------------------------------

// ---------------------------------------------- Section 0: To-Do List & Credits

// ---------------------------------------------- Section 1: const int declarations
// ---------------------------------------------- Section 1B: Relist of above ->Misc[] attributes for ease of checking

// ---------------------------------------------- Section 2: Global int and bool declarations

// ---------------------------------------------- Section 3: Global scale functions

// ---------------------------------------------- Section 4: Global script 
// Global script has it's own index of chapters

// ---------------------------------------------- Section 5: Item scripts

// ---------------------------------------------- Section 6: FFC scripts







// ---------------------------------------------- Section 0: To-Do List & Credits

//ToDo list: 	
//		Employ FFCScript.zh?
//		
//		Finish Title / Intro sequence and credits
//		Double check that the contest requires a Z1 ending sequence to work
//
//		Enemies (vanilla editor)
//			-Byrna patras
//
//
//		Enemies (scripted)
//			-Crazy Patras FFC script (finish)
//			-Figure out Ghost.zh?
//			-Moby
//			-Wizzrobes that turn the floor into spinning tiles
//			-Wizzrobes that turn the floor into spikes
//			-Fireball shooting tektites
//			-Bait that attracts player
//			-Patra- Triangle, Square, Diamond, Cross, BS Twins
//			-Gain shooters later in fight
//
//		-FFC secret triggers
//
//		Map / screen / dungeon design (overworld is started)

//Credits:

// --- Assistance / content used:
// Bigjoe: 5thmusic.nsf
// IsabelleChiming: z1remade.nsf and z2remade.nsf
// Klopp422: zeldansf-1.nsf
// Moosh: "Progressive Gear" 4 way movement simulation from Brock Lesnar.qst, scripting advice, encouragement
// Dimentio: Encouragement, scripting advice, ZC interface advice
// P-Tux: Darknut Naga (Darkrope) sprites, "BS Grave" combo ideas
// Venrob: Scripting advice
// ZoriaRPG: Scripting advice, Classic.zh

// --- Special thanks:
// MeleeWizard: Helping me get back into ZC through Let's Play videos

// --- Zelda Classic creator:
// Phantom Menace

// --- Zelda Classic developers:
// WarLord
// DarkNation
// DarkDragon
// Gleeok
// _L_
// Saffith
// Joe123
// ZoriaRPG
// Tamamo / Mero
// jman2050
// PKMNFRK
// Wolfman2000
// Sean
// Takuya
// Venrob

// --- Original Legend of Zelda by Nintendo

// --- Quest creator
// Mitsukara










// ---------------------------------------------- Section 1: const int declarations




// --- Miscellaneous

const int CT_SIDECLIMB = 143;		// Sideview ladder climbing combos. Currently uses CT_SCRIPT2.

const int CR_LINKSTUN = 8;		// Counter ID for Link being stunned. Currently using CR_SCRIPT2.

const int SFX_PLAYERFALL = 66;		// Sound effect for the player falling in sideview

const int IS_BIGENEMY = 24;		// npc->ItemSet checked for setting an enemy to 2x2 size from the enemy editor.

const int MISC_NPCSHOOT = 4;		// NPC->Misc[] index used as a timer for creating weapons on NPCs which do not normally have weapon-firing capabilities, such as NPCT_KEESE




// --- Windy Screen effects

const int SP_WINDY = 115;		// Weapon sprite for windy screens
const int SFX_WINDY = 59;		// Sound effect to play for windy (currently uses Whistle Whirlwind slot)




// --- Growing Manhandala FFC script

const int HEAD_DOWN_A = 1;		// Used by "Growing Mandhandla" FFC script in the array "ManOffset[]".
const int HEAD_DOWN_B = 2;		// Used by "Growing Mandhandla" FFC script in the array "ManOffset[]".
const int HEAD_DOWN_C = 3;		// Used by "Growing Mandhandla" FFC script in the array "ManOffset[]".
const int HEAD_LEFT_A = 4;		// Used by "Growing Mandhandla" FFC script in the array "ManOffset[]".
const int HEAD_LEFT_B = 5;		// Used by "Growing Mandhandla" FFC script in the array "ManOffset[]".
const int HEAD_LEFT_C = 6;		// Used by "Growing Mandhandla" FFC script in the array "ManOffset[]".
const int HEAD_RIGHT_A = 7; 		// Used by "Growing Mandhandla" FFC script in the array "ManOffset[]".
const int HEAD_RIGHT_B = 8;		// Used by "Growing Mandhandla" FFC script in the array "ManOffset[]".
const int HEAD_RIGHT_C = 9;		// Used by "Growing Mandhandla" FFC script in the array "ManOffset[]".




// --- Cane of Somaria item

const int I_SOMARIACANE1 = 150;		// Cane of Somaria 1 item ID
const int I_SOMARIACANE2 = 151;		// Cane of Somaria 2 item ID
const int I_SOMARIACANE3 = 152;		// Cane of Somaria 3 item ID
const int I_SOMARIABOOK = 32;		// Book of Somaria item ID (makes beams when destroying block). Currently uses I_BOOK.
const int LW_SOMARIA = 35;		// Somaria Block LWeapon type. Currently using LW_SCRIPT5.
const int SP_SOMARIABLOCK = 97;		// Block of Somaria sprite.
const int SP_SOMARIABEAM = 105;		// Cane of Somaria beam weapon sprite.
const int SFX_SOMARIA = 63;		// Cane of Somaria block being placed / removed.





// --- Medicine item

const int I_BLUEMEDICINE = 172;		// Medicine Item ID
const int I_REDMEDICINE = 173;		// Medicine 2 Item ID




// --- Hiding Shellmet item

const int I_SHELLMET = 175;		// Hiding Shellmet Item ID
const int SHELLMET_TILE = 19798;	// Hiding Shellmet tile to draw.




// --- Guardian Acorns item

const int CR_ACORNS = 7;		// Counter ID for guardian acorns. Currently using CR_SCRIPT1.
const int I_GUARDIANACORN = 174;	// Guardian Acorn Item ID
const int I_ACORNBLUE = 17;		// Blue ring item ID given by Guardian acorn. Currnetly using I_RING1.
const int I_ACORNRED = 18;		// Red ring item ID given by Guardian acorn. Currently using I_RING2.




// --- Handy Glove item

const int CT_HANDYBLOCK = 144;		// Handy glove block combo type (break with sword). Currently uses CT_SCRIPT3.
const int I_HANDYGLOVE = 169;		// Handy glove item ID




// --- Lantern item

const int I_LANTERN = 171;		// Lantern Item ID
const int LANTERN_TILE = 20055;		// 5x5 tile block drawn around Link when the lantern is on.




// --- Bola item

const int LW_BOLA = 33;			// Bola LWeapon type. Currently using LW_SCRIPT3.
const int MISC_BOLA = 1;		// LWeapon->Misc[] used for a Bola movement timer, on LW_BOLA weapons only.




// --- Bola (enemy weapon)

const int EW_BOLA = 31;			// Enemy bola EWeapon type. Currently using EW_SCRIPT1.
const int IS_BOLA = 13;			// npc->ItemSet used for switching an enemy's weapon type to EW_BOLA.
const int EWBOLA_ORIGINAL_TILE = 19880;	// First tile of the enemy bola animation.
const int SP_EWBOLA = 123;		// Enemy bola weapon sprite. Must start with EWBOLA_ORIGINAL_TILE.
const int MISC_EWBOLA = 1;		// EWeapon->Misc[] used for a Bola movement timer, on EW_BOLA weapons only.




// --- Mace (enemy weapon)

const int EW_MACE = 33;			// Enemy mace EWeapon type (bouncing Doomknocker maces). Currently using EW_SCRIPT3.
const int IS_MACE = 15;			// npc->ItemSet used for switching an enemy's weapon type to EW_MACE.
const int MISC_EWMACE = 1;		// EWeapon->Misc[] used for a Morning Star timeout, on EW_MACE weapons only.
const int SP_MACE = 126;		// Enemy mace weapon sprite.




// --- Stationary enemy bombs

const int EW_STATIONARYBOMB = 32;	// Eweapon type used for enemies laying bombs on the ground (Sluggula bombs). Currently using EW_SCRIPT2.
const int IS_STATIONARYBOMB = 14;	// npc->ItemSet used for switching an enemy's weapon type to EW_STATIONARYBOMB.
const int SP_EWSTATIONARYBOMB = 124;	// Enemy stationary bomb weapon sprite.
const int MISC_STATIONARYFUSE = 1;	// EWeapon->Misc[] used for the stationary bomb's detonation timer, on EW_STATIONARYBOMB weapons only.




// --- Armos item

const int I_ARMOS = 188;		// Armos item ID
const int LW_ARMOS = 38;		// Armos LWeapon type. Currently uses LW_SCRIPT8.
const int SP_ARMOS = 117;		// Armos weapon sprite (moving).
const int SP_ARMOSWAKE = 116;		// Armos weapon sprite (mid-activation).
const int SP_ARMOSSLEEP = 122;		// Armos weapon sprite (deactivated).
// ArmosStatus[] array indexes
const int FRIEND_TIMER = 1;		// Armos movement timer
const int FRIEND_IFRAMES = 2;		// Armos invincibility frames after getting hit
const int FRIEND_STARTX = 3;		// Armos Wake-up X position
const int FRIEND_STARTY = 4;		// Armos Wake-up Y position
const int FRIEND_LINK_STARTX = 5;	// Link's X position when Armos wakes up
const int FRIEND_LINK_STARTY = 6;	// Link's Y position when Armos wakes up
const int FRIEND_GOX = 7;		// Armos X to go to
const int FRIEND_GOY = 8;		// Armos Y to go to
const int FRIEND_HP = 9;		// Armos HP
const int FRIEND_SNOOZE = 10;		// Checked when Armos is deactivated

// --- Big Armos obstacles

const int NPC_BIGARMOS = 236;		// NPC ID for Big Armos to be spawned by "Big Armos" FFC script
const int BIGARMOS_TILE = 10282;	// Tile usde to draw Big Armos when waking up, in the "Big Armos" FFC Script




// --- Beetle Keese item

const int I_BEETLE = 153;		// Beetle 1 Item ID
const int I_STRONGBEETLE = 154;		// Beetle 2 Item ID
const int LW_BEETLE = 31;		// Beetle LWeapon type. Currently using LW_SCRIPT1.
const int SP_BEETLE = 89;		// Beetle 1 Weapon sprite
const int SP_STRONGBEETLE = 90;		// Beetle 2 Weapon sprite
const int SP_BEETLECARRY = 91;		// Beetle 1 carrying an object sprite
const int SP_STRONGCARRY = 92;		// Beetle 2 carrying an object sprite
const int SP_BEETLEPOOF = 93;		// Beetle destroyed sprite
const int SFX_BEETLE = 4;		// Sound effect played by deploying the beetle. Currently using SFX_BRANG.
//const int SFX_BEETLE = 62;		// Actual beetle sound, included in the quest but not used.
const int BEETLE_RANGE = 48;		// Range limit of Beetle 1. LaZPoC range was 64.




// --- Rope item

const int SFX_ROPE = 73;		// Sound effect for the Rope item.
const int LW_ROPE = 32;			// Rope LWeapon type. Currently using LW_SCRIPT2.
					// Note: The Rope sprites are set in the arguments of the item script which deploys the rope.



// --- Enemy "firing" LWeapons (usde by Good Octorok item)

const int MISC_NPCLWEAPON = 2;		// NPC->Misc[] attribute to use for firing an lweapon instead of a weapon; used for Octorok item
const int MISC_NPCLWEAPONSPRITE = 3;	// NPC->Misc[] attribute to use for lweapon sprites; used for Octorok item
const int MISC_NPCLWEAPONTIMER = 4;	// NPC->Misc[] attribute to use for waiting for firing an lweapon.
const int MISC_TEMPNOCOLLIDELW = 2;	// LWeapon->Misc[] attribute to use for temporary deactivation of collision detection.




// --- Shovel item

const int I_SHOVEL = 155;		// Shovel item ID.
const int SHOVEL_TILE = 19821;		// Shovel digging animation starting tile.
const int SP_SHOVELDIRT = 101;		// Shovel dirt sparkle weapon sprite
const int SFX_SHOVEL = 71;		// Sound effect for shovel when digging successfully.
const int SHOVEL_POTHOLE = 5380;	// Combo for the shovel to leave behind after digging.
const int MISC_SHOVELFIND = 1;		// LWeapon->Misc[] used for randomly finding items with the shovel, on shovel dirt sparkle lweapons only.
const int CF_SHOVELSECRET = 9;		// Flag for digging up a secret combo (RoomData). Currenly uses CF_ARMOSSECRET.
const int CF_SHOVELITEM = 13;		// Flag for digging up a secret item (RoomData). Currenly uses CF_DIVEITEM.
const int CT_DIGDIRT = 142;		// Combo type for diggable dirt. Currently uses CT_SCRIPT1.




// --- Magic Bean Leevers item

const int I_MAGICBEAN = 156;		// Magic bean item ID.
const int LW_LEEVER = 36;		// LWeapon type for Magic Bean leevers. Currently using LW_SCRIPT6
const int SP_LEEVER = 112;			// Magic Bean Leever weapon sprite.




// --- Unscriped pickup items

const int I_RUPOOR = 185;		// Rupoor item ID (used by shovel on very rare occasions). Non-scriped rupee that reduces Link's rupees by 1, although a line of the global script (search for "underflow") prevents this from underflowing the rupee counter (collecting -1 at 0 rupees goes to 65535.)
const int I_HEARTTWO = 186;		// Blue Heart Item ID. Non-sripted heart that gives two hearts.
const int I_NEGAHEART = 193;		// Negative heart item ID. Non scripted heart that reduces Link's health by a heart.




// --- Pegasus boots item

const int I_PEGASUS = 157;		// Pegasus Boots 1 Item ID
const int I_SUPERPEGASUS = 158;		// Pegasus Boots 2 Item ID 
const int SP_PEGASUSDUST = 102;		// Pegasus Boots Dust sprite
const int SP_PEGASUSBREAK = 104;	// Pegaus Boots breaking an obstacle sprite
const int CT_PEGASUSOBSTACLE = 9;	// A combo type which the Pegasus Boots can break, replacing with Screen->Undercombo. Currently uses CT_PUSHHEAVY.
const int SFX_PEGASUS = 68;		// Pegaus Boots dash sound effect
const int SFX_PEGABONK = 9;		// Pegasus Boots bonk sound effect (current is shutter door)
const int SFX_SHATTERING = 70;		// Pegasus boots break something sound effect. Also used by Handy Glove.
const int SFX_PEGAITEM = 69;		// Sound to play when Pegasus boots spawn an item.
const int CF_PEGASTOP = 98;		// Flag for preventing dashing with the Pegasus boots. Currently uses CF_SCRIPT1.
const int CF_PEGASUSSECRET = 9;		// Flag for breaking a Pegasus Obstacle to reveal a secret combo (RoomData). Currenly uses CF_ARMOSSECRET.
const int CF_PEGASUSITEM = 13;		// Flag for boot-bonking to spawn a secret item (RoomData). Currenly uses CF_DIVEITEM.




// --- Pegasus boots lanmola trail item

const int SP_PEGASUSDUST2 = 103;	// Pegasus Boots 2 Dust sprite (Lanmola)
const int LW_LANMOLA = 37;		// LWeapon type for Pegasus Boots Lanmola. Currently using LW_SCRIPT7.
const int MISC_LWTIMEOUT = 3;		// Lweapon->Misc[] attribute to remove an lweapon when time is elapsed.




// --- Fishing Rod item

const int I_FISHINGROD = 161;		// Fishing rod Item ID
const int FISHINGROD_TILE = 19901;	// Fishing rod animation starting tile.




// --- Boots items

//const int I_BOOTS = 55;		Vanilla STD_CONSTANTS boots identifier, used in this global. This item's Power is changed based on a scripted effect of slowly using up rupees to prevent spike damage.
const int I_BOOTSTWO = 170;		// Level 2 boot item. These are vanilla "infinite" boots, but are checked to prevent the script from draining rupees on spikes.




// --- Auto Life Refill mode

//const int I_HEARTRING1 = 112;		Vanilla STD_CONSTANTS heart ring 1 identifier, used by the mode menu for Auto Life Refill.
const int AUTOLIFE_TILE = 19855;	// Tile used by the mode menu for Auto Life Refilll mode.




// --- Full Starting Hearts mode

const int I_STARTHEARTS = 194;		// Full Starting Hearts mode item ID
const int STARTHEARTS_TILE = 19858;	// Tile used by the mode menu for Full Starting Hearts mode.




// --- Tougher Monsters mode

const int I_TOUGHMONSTERS = 183;	// Tough Monsters mode item ID
const int MISC_TOUGHENEMY = 1;		// npc->Misc[] attribute used to set the tough enemy status once to each npc.
const int TOUGHER_TILE = 19857;		// Tile used by the mode menu for Tougher Monsters mode.




// --- No Heart Drops mode

const int I_NOHEARTS = 182;		// No Heart Drops mode item ID
const int NOHEART_TILE = 19858;		// Tile used by the mode menu for No Hearts mode.




// --- 8 Way Walk mode (see Moosh's function "FourWayCurse")

const int I_PROGRESSIVEGEAR = 181;	// Item to negate Moosh's 4 way movement curse script (8 way movement mode item)
const int GEAR_TILE = 19856;		// Tile used by the Mode Menu for 8 way walk mode.




// --- Zapper mode

const int I_ZAPPER = 184;		// Duck Zapper Item ID
const int COMBO_DUCK = 5382;		// Duck combos to draw at mouse pointer; uses a 2x2 block of combos with COMBO_DUCK in the top left. 
const int DUCK_TILE = 19854;		// Tile used by the Mode Menu for Zapper mode. Ooh-woo-ooh.
const int SFX_DUCK = 67;		// Duck sound effect.




// --- Bow Wow item / mode
// Haven't decided whether Bow Wow may feature as an actual game item instead of just a mode.

const int I_BOWWOW = 190;		// Bow-Wow Item ID
const int I_BOWWOWDETECTOR = 191;	// Shows meat at Bow-Wow's GOX and GOY. Not really intended as a gameplay item but it was a debug feature I decided to leave in the cheats menu.
const int LW_BOWWOW = 39;		// Bow-Wow LWeapon type. Currently Using LW_SCRIPT9.
const int SP_BOWWOWUP = 118;		// Weapon sprite for Bow-Wow (facing up)
const int SP_BOWWOWDOWN = 119;		// Weapon sprite for Bow-Wow (facing down)
const int SP_BOWWOWLEFT = 120;		// Weapon sprite for Bow-Wow (facing left)
const int SP_BOWWOWRIGHT = 121;		// Weapon sprite for Bow-Wow (facing right)
const int BOWWOWCHAIN_TILE = 19941;	// BowWow Chain tile
//BowWowStatus[] array incies:
const int BOWWOW_TIMER = 1;		//Bow-Wow movement timer.
const int BOWWOW_EAT = 2;		//Bow-Wow random eating.
const int BOWWOW_GOX = 3;		//Bow-Wow tries to go to X.
const int BOWWOW_GOY = 4;		//Bow-Wow tries to go to Y.
const int BOWWOW_BOUNCE = 5;		//Bow-Wow bouncing animation offset.
const int SFX_BOWWOW = 74;		//Bow-Wow barking sound effect.
const int CF_BOWWOW = 99;		//Flag to make combos edible by Bow-Wow (will leave undercombos behind). Currently uses CF_SCRIPT2.
const int BOWWOW_TILE = 19859;		// Tile used by the Mode Menu for Bow-Wow mode.




// --- Link Costume mode

const int LINKCOSTUME_TILE = 19839;	// Tile used by the Mode Menu for Link Costume mode.
const int I_LINKCOSTUME = 197;		// Link Costume Item ID
const int ZELDA_TILES = 35120;		// Starting tile for Zelda's tiles. Used to copytile over for the Link Costume.
const int LINKCOPY_TILE = 35380;	// Starting tile for Link tiles to copy over Zelda.
const int ZELDACOPY_TILE = 35640;	// Starting tile for duplicate Zelda tiles to copy back in over Link.
const int LINKVICTORY_TILES = 35600;	// Starting tile for Link end-of-game tiles to copy over Zelda.
const int ZELDAVICTORY_TILES = 35860;	// Starting tile for duplicate Zelda end-of-game tiles to copy back over Link.
const int ORIGINALVICTORY_TILES = 28;	// Starting tile for ZC's hard-coded victory tiles for the ending.
const int SFX_LINKHURT = 75;		// Sound effect for "Link" to get hurt
const int SFX_ZELDAHURT = 76;		// Sound effect for Zelda to get hurt




// --- Shield mode

const int SHIELD1_TILE = 19879;		// Tile used by the Mode Menu for the Shield.




// --- Mode Menu

const int SFX_MODEON = 65;		// Sound effect for turning on a special mode
const int SFX_MODEOFF = 18;		// Sound effect for turning off a special mode. Currently uses SFX_MSG.

//Array indices for ModeMenu[]
const int MODEMENU_ON = 1;		// Checked to see if the mode menu is active.
const int SELECT_MODE = 2;		// Selects which mode setting to adjust.
const int SELECT_MUSICFILE = 3;		// Selects which music filename is playing.
const int SELECT_MUSICTRACK = 4;	// Selects which music track is playing.
const int UNDO_MUSICFILE = 5;		// By pressing B on the mode menu, SELECT_MUSICFILE is reverted to this.
const int UNDO_MUSICTRACK = 6;		// By pressing B on the mode menu, SELECT_MUSICTRACK is reverted to this.
const int CHANGE_DMAPS = 7;		// Tracks when Link changes dmaps, to remember the Undo settings.




// ---------------------------------------------- Section 1B: Relist of above ->Misc[] attributes for ease of checking
//
// NPC->Misc[]
//
//const int MISC_TOUGHENEMY = 1;	// npc->Misc[] attribute used to set the tough enemy status once to each npc.
//const int MISC_NPCLWEAPON = 2;	// NPC->Misc[] attribute to use for firing an lweapon instead of a weapon; used for Octorok item
//const int MISC_NPCLWEAPONSPRITE = 3;	// NPC->Misc[] attribute to use for lweapon sprites; used for Octorok item
//const int MISC_NPCSHOOT = 4;		// NPC->Misc[] index used as a timer for creating weapons on NPCs which do not have weapon-firing capabilities
//
//
//
// LWeapon->Misc[]
//
//const int MISC_BOLA = 1;		// LWeapon->Misc[] used for a Bola movement timer, on LW_BOLA weapons only.
//const int MISC_SHOVELFIND = 1;	// LWeapon->Misc[] used for randomly finding items with the shovel, on shovel dirt sparkle lweapons only.
//const int MISC_TEMPNOCOLLIDELW = 2;	// LWeapon->Misc[] attribute to use for temporary deactivation of collision detection.
//const int MISC_LWTIMEOUT = 3;		// Lweapon->Misc[] attribute to remove an lweapon when time is elapsed.
//const int MISC_NPCLWEAPONTIMER = 4;	// NPC->Misc[] attribute to use for waiting for firing an lweapon.
//
//
// EWeapon->Misc[]
//
//const int MISC_EWBOLA = 1;		// EWeapon->Misc[] used for a Bola movement timer, on EW_BOLA weapons only.
//const int MISC_STATIONARYFUSE = 1;	// EWeapon->Misc[] used for the stationary bomb's detonation timer, on EW_STATIONARYBOMB weapons only.
//
//








// ---------------------------------------------- Section 2: Global int and bool declarations
// Just the one currently.

bool DoDraw = true;			// Global-scope bool used to prevent drawing at inappropriate times (if false)










// ---------------------------------------------- Section 3: Global scale functions

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// Functions at global scope (start)
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------


// ---------------- PushLink() Link-moving function
void PushLink(int PushLinkDir)
{
	if (PushLinkDir == DIR_UP && CanWalk(Link->X,Link->Y,DIR_UP,1,false)) Link->Y --;
	if (PushLinkDir == DIR_DOWN && CanWalk(Link->X,Link->Y,DIR_DOWN,1,false)) Link->Y ++;
	if (PushLinkDir == DIR_LEFT && CanWalk(Link->X,Link->Y,DIR_LEFT,1,false)) Link->X --;
	if (PushLinkDir == DIR_RIGHT && CanWalk(Link->X,Link->Y,DIR_RIGHT,1,false)) Link->X ++;
}
	// To-do: Incorporate PushLink() into Pegasus boots? (but those check if Link was going to collide with a solid to do the bonk and obstacle break, so it would need a rewrite)


// ---------------- Pegasus boot functions (start)

void PegasusShrapnel()
{
	Game->PlaySound(SFX_SHATTERING);
	lweapon PegaShrapnel = CreateLWeaponAt(LW_SPARKLE,Link->X,Link->Y);
	PegaShrapnel->UseSprite(SP_PEGASUSBREAK);
	PegaShrapnel->Dir = DIR_LEFTUP;
	PegaShrapnel->Step = 100;
	PegaShrapnel = CreateLWeaponAt(LW_SPARKLE,Link->X,Link->Y);
	PegaShrapnel->UseSprite(SP_PEGASUSBREAK);
	PegaShrapnel->Flip = FLIP_HORIZONTAL;
	PegaShrapnel->Dir = DIR_RIGHTUP;
	PegaShrapnel->Step = 100;
	PegaShrapnel = CreateLWeaponAt(LW_SPARKLE,Link->X,Link->Y);
	PegaShrapnel->UseSprite(SP_PEGASUSBREAK);
	PegaShrapnel->Flip = FLIP_VERTICAL;
	PegaShrapnel->Dir = DIR_LEFTDOWN;
	PegaShrapnel->Step = 100;
	PegaShrapnel = CreateLWeaponAt(LW_SPARKLE,Link->X,Link->Y);
	PegaShrapnel->UseSprite(SP_PEGASUSBREAK);
	PegaShrapnel->Flip = FLIP_BOTH;
	PegaShrapnel->Dir = DIR_RIGHTDOWN;
	PegaShrapnel->Step = 100;
}

void PegasusBonk()
{
	if (Link->Dir == DIR_UP && Screen->ComboT[ComboAt(Link->X+7,Link->Y-1)] != CT_WATER || Link->Dir == DIR_DOWN && Screen->ComboT[ComboAt(Link->X+7,Link->Y+17)] != CT_WATER || Link->Dir == DIR_LEFT && Screen->ComboT[ComboAt(Link->X-1,Link->Y+8)] != CT_WATER || Link->Dir == DIR_RIGHT && Screen->ComboT[ComboAt(Link->X+17,Link->Y+8)] != CT_WATER){
		Game->PlaySound(SFX_PEGABONK);
		Link->Z = 1;
		Link->Jump = 2;
		if (Screen->Quake <= 0) Screen->Quake = 8;
		if (!Screen->State[ST_SPECIALITEM])
		{
			if (Link->Dir == DIR_UP)
			{
				if (Screen->ComboF[ComboAt(Link->X+7,Link->Y-1)] == CF_PEGASUSITEM)
				{
					Screen->ComboF[ComboAt(Link->X+7,Link->Y-1)] = CF_NONE;
					item BootGet = CreateItemAt(Screen->RoomData,ComboX(ComboAt(Link->X+7,Link->Y-1)),ComboY(ComboAt(Link->X+7,Link->Y-1)-16));
					BootGet->Pickup = IP_ST_SPECIALITEM + IP_HOLDUP;
					BootGet->Jump = 1;
					Game->PlaySound(SFX_PEGAITEM);
				}
			}

			if (Link->Dir == DIR_DOWN)
			{
				if (Screen->ComboF[ComboAt(Link->X+7,Link->Y+17)] == CF_PEGASUSITEM)
				{
					Screen->ComboF[ComboAt(Link->X+7,Link->Y+17)] = CF_NONE;
					item BootGet = CreateItemAt(Screen->RoomData,ComboX(ComboAt(Link->X+7,Link->Y+17)),ComboY(ComboAt(Link->X+7,Link->Y+17)+16));
					BootGet->Z = 16;
					BootGet->Pickup = IP_ST_SPECIALITEM + IP_HOLDUP;
					Game->PlaySound(SFX_PEGAITEM);
				}
			}

			if (Link->Dir == DIR_LEFT)
			{
				if (Screen->ComboF[ComboAt(Link->X-1,Link->Y+8)] == CF_PEGASUSITEM)
				{
					Screen->ComboF[ComboAt(Link->X-1,Link->Y+8)] = CF_NONE;
					item BootGet = CreateItemAt(Screen->RoomData,ComboX(ComboAt(Link->X-1,Link->Y+8))-16,ComboY(ComboAt(Link->X-1,Link->Y+8)));
					BootGet->Jump = 1;
					BootGet->Pickup = IP_ST_SPECIALITEM + IP_HOLDUP;
					Game->PlaySound(SFX_PEGAITEM);
				}
			}

			if (Link->Dir == DIR_RIGHT)
			{
				if (Screen->ComboF[ComboAt(Link->X+17,Link->Y+8)] == CF_PEGASUSITEM)
				{
					Screen->ComboF[ComboAt(Link->X+17,Link->Y+8)] = CF_NONE;
					item BootGet = CreateItemAt(Screen->RoomData,ComboX(ComboAt(Link->X+17,Link->Y+8))+16,ComboY(ComboAt(Link->X+17,Link->Y+8)));
					BootGet->Jump = 1;
					BootGet->Pickup = IP_ST_SPECIALITEM + IP_HOLDUP;
					Game->PlaySound(SFX_PEGAITEM);
				}
			}
		}
	}
}

// ---------------- Pegasus boot functions (end; see "Item: Pegasus Boots" below)







// ---------------- Moosh's 4 Way Curse script from Brock Lesnar.qst (start)

void SetInputDir(int Dir)
{
	if(Link->Dir==DIR_UP) Link->InputUp = true;
	else if(Link->Dir==DIR_DOWN) Link->InputDown = true;
	else if(Link->Dir==DIR_LEFT) Link->InputLeft = true;
	else if(Link->Dir==DIR_RIGHT) Link->InputRight = true;
}


void FourWayCurse(int FWC)
{
	// Make sure to call FourWayCurse() as late as possible in the global script (but before WaitDraw(), so that it doesn't stop input checks from working.

	bool u;
	bool d;
	bool l;
	bool r;
	if(!Link->Item[I_PROGRESSIVEGEAR])
	{

		if (Link->InputLeft && Link->InputUp || Link->InputLeft && Link->InputDown || Link->InputRight && Link->InputUp || Link->InputRight && Link->InputDown)
		{
			if (Link->Action == LA_WALKING)
			{
				Link->InputLeft = false;
				Link->InputRight = false;
			}
		}
		else
		{
			u = Link->InputUp;
			d = Link->InputDown;
			l = Link->InputLeft;
			r = Link->InputRight;
			if(Link->PressUp)
			{
				FWC[0] = 0;
			}
			else if(Link->PressDown)
			{
				FWC[0] = 1;
			}
			else if(Link->PressLeft)
			{
				FWC[0] = 2;
			}
			else if(Link->PressRight)
			{
				FWC[0] = 3;
			}
			int ButtonsPressed;
			if(u) ButtonsPressed++;
			if(d) ButtonsPressed++;
			if(l) ButtonsPressed++;
			if(r) ButtonsPressed++;
			Link->InputUp = false;
			Link->InputDown = false;
			Link->InputLeft = false;
			Link->InputRight = false;
			if(ButtonsPressed>1)
			{
				u = false;
				if(FWC[0]==0) u = true;
				d = false;
				if(FWC[0]==1) d = true;
				l = false;
				if(FWC[0]==2) l = true;
				r = false;
				if(FWC[0]==3) r = true;
				Link->InputUp = false;
				Link->InputDown = false;
				Link->InputLeft = false;
				Link->InputRight = false;
			}
			if(u)
			{
				if(Link->X%8==0)
				{
					Link->InputUp = true;
				}
				else if(Link->X%8==1||Link->X%8==7)
				{
					Link->X = Round((Link->X)/8)*8;
					Link->InputUp = true;
				}
				else if(Link->Dir==DIR_DOWN)
				{
					Link->X = Round((Link->X)/8)*8;
					Link->InputUp = true;
				}
				else
				{
					SetInputDir(Link->Dir);
				}
			}
			else if(d)
			{
				if(Link->X%8==0)
				{
					Link->InputDown = true;
				}
				else if(Link->X%8==1||Link->X%8==7)
				{
					Link->X = Round((Link->X)/8)*8;
					Link->InputDown = true;
				}
				else if(Link->Dir==DIR_UP)
				{
					Link->X = Round((Link->X)/8)*8;
					Link->InputDown = true;
				}
				else
				{
					SetInputDir(Link->Dir);
				}
			}
			else if(l)
			{
				if(Link->Y%8==0)
				{
					Link->InputLeft = true;
				}
				else if(Link->Y%8==1||Link->Y%8==7)
				{
					Link->Y = Round((Link->Y)/8)*8;
					Link->InputLeft = true;
				}
				else if(Link->Dir==DIR_RIGHT)
				{
					Link->Y = Round((Link->Y)/8)*8;
					Link->InputLeft = true;
				}
				else
				{
					SetInputDir(Link->Dir);
				}
			}
			else if(r)
			{
				if(Link->Y%8==0)
				{
					Link->InputRight = true;
				}
				else if(Link->Y%8==1||Link->Y%8==7)
				{
					Link->Y = Round((Link->Y)/8)*8;
					Link->InputRight = true;
				}
				else if(Link->Dir==DIR_LEFT)
				{
					Link->Y = Round((Link->Y)/8)*8;
					Link->InputRight = true;
				}
				else
				{
					SetInputDir(Link->Dir);
				}
			}
		}
	}
}

// ---------------- Moosh's 4 Way Curse script from Brock Lesnar.qst (end; function is called once during Global script)

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// Functions at global scope (end)
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------















// ---------------------------------------------- Section 4: Global script 

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// Global script (Start)
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------



global script Plan6Global{
	void run(){



// --------------------------------------------------------
// --------------------------------------- Index of Global:
// --------------------------------------------------------

// --------------------------------------- Chapter 1: int, bool, lweapon, eweapon, npc, item declarations

// --------------------------------------- Chapter 2: First actions (before While)

// --------------------------------------- Chapter 3: While loop begins

// --------------------------------------- Chapter 4: Prevent rupoor underflow

// --------------------------------------- Chapter 5: Link (Zelda) is stunned

// --------------------------------------- Chapter 6: Mode menu

// --------------------------------------- Chapter 7: Link drowns, but only in Sideview  Link drowns, but only in Sideview 

// --------------------------------------- Chapter 8: Sideview Ladder combos

// --------------------------------------- Chapter 9: Spike-walking boots drain rupees slowly

// --------------------------------------- Chapter 10: Item: Medicine

// --------------------------------------- Chapter 11: Item: Hiding Shellmet

// --------------------------------------- Chapter 12: Item: Guardian Acorn

// --------------------------------------- Chapter 13: Item: Duck Zapper

// --------------------------------------- Chapter 14: Item: Bow-Wow

// --------------------------------------- Chapter 15: Every-frame Item checks / for loop of Items

// --------------------------------------- Chapter 16: Every-frame EWeapon checks / for loop of EWeapons

// --------------------------------------- Chapter 17: Every-frame NPC checks / for loop of NPCs

// --------------------------------------- Chapter 18: Every-frame LWeapon checks / for loop of Lweapons

// --------------------------------------- Chapter 19: Item: Armos

// --------------------------------------- Chapter 20: Item: Pegasus Boots 

// --------------------------------------- Chapter 21: Item: Cane of Somaria and Item: Handy Glove

// --------------------------------------- Chapter 22: Somaria pushblocks

// --------------------------------------- Chapter 23: Item: Shovel

// --------------------------------------- Chapter 24: Item: Rope

// --------------------------------------- Chapter 25: Link (Zelda) falls like a rock in sideview

// --------------------------------------- Chapter 26: Item: Beetle

// --------------------------------------- Chapter 27: Windy Screens

// --------------------------------------- Chapter 28: Call FourWayCurse

// --------------------------------------- Chapter 29: Item: Lantern

// --------------------------------------- Chapter 30: Waitdraw()






// --------------------------------------- Chapter 1: int, bool, lweapon, eweapon, npc, item declarations

		int WindyTimer;		// Timer for windy screens.

		int StoodStill;		// A timer for how long Link (Zelda) has stood still, to don the shellmet.
		bool ShellmetOn;	// Checks when Link (Zelda) is wearing the shellmet.

		bool BeingHurt;		// Checks when Link (Zelda) is hit for the Guardian Acorn counter.

		bool IsDark;		// Set to true once Link (Zelda) enters a custom-dark room so it doesn't "light up" while scrolling away.

		bool LeftRight;		// Checks whether Link (Zelda) has more recently pressed left or right.

		bool HoldingMouse;	// Used to make mouse effects once-per-click (in lieu of "PressMouseB" existing).
		int DuckDelay;		// Delay on the duck.

		lweapon SomariaBlock;	// LWeapon identifier for Cane of Somaria blocks.

		bool MagnetHold;	// True if holding the magnet button, affects magnet inventory switch.
		lweapon MagnetBeam;	// Lweapon identifier for the magnet
		int MagnetDir;		// Direction tracker for magnet strafing

		bool PegasusDash;	// True if dashing.
		int PegasusTimer;	// Timer used for dashing with pegasus boots.
		int PegasusDir;		// Tracks Link->Dir when charging with boots.
		
		int SpikeBootsTimer;	// Timer for vanilla spike-resistant boots to use up rupees slowly.

		bool DeadBeetle;	// Bool that checks if Beetle is destroyed.
		bool BeetleCarrying;	// Bool that sets the Beetle into "carrying an object" mode.
		lweapon Beetle;		// Lweapon identifier for the Beetle.
		lweapon BeetleLW;	// LWeapon being carried by the Beetle.
		eweapon BeetleEW;	// EWeapon being carried by the Beetle.
		item BeetleItem;	// Item being carried by the Beetle.

		lweapon RopeWeapon;	// LWeapon identifier for the rope.

		lweapon ArmosFriend;	// LWeapon identifier for the Armos.
		int ArmosStatus[11];	// Armos item movement array.
		//FRIEND_TIMER = 1;
		//FRIEND_IFRAMES = 2;
		//FRIEND_STARTX = 3;
		//FRIEND_STARTY = 4;
		//FRIEND_LINK_STARTX = 5;
		//FRIEND_LINK_STARTY = 6;
		//FRIEND_GOX = 7;
		//FRIEND_GOY = 8;
		//FRIEND_HP = 9;
		//FRIEND_SNOOZE = 10;
		ArmosStatus[FRIEND_HP] = 2;

		lweapon BowWow;		// LWeapon identifier for BowWow.
		int BowWowStatus[6];
		//BOWWOW_TIMER		Bow-Wow movement timer.
		//BOWWOW_EAT		Bow-Wow random eating.
		//BOWWOW_GOX		Bow-Wow tries to go to X.
		//BOWWOW_GOY		Bow-Wow tries to go to Y.
		//BOWWOW_BOUNCE		Bow-Wow bouncing animation offset.
		npc BowWowTarget;	// NPC for Bow-wow to attempt to eat.

		int DigDelay;		// Shovel timer.
		lweapon DirtThrow;	// LWeapon identifier for shovel dirt; also used to figure out dug-up items.

		lweapon randoLW;	// A general-purpose LWeapon that is used to check all LWeapons in loops.
		eweapon randoEW;	// A general-purpose EWeapon that is used to check all EWeapons in loops.
		npc randoNPC;		// A general-purpose NPC that is used to check all NPCs in loops.
		item randoitem;		// A general-purpose item that is used to check all items in loops.
		itemdata randoitemdata;	// A general-purpose itemdata that is used to check all itemdata in loops.
		int ForTimer;		// Used in "for" statements that count a varying number of things, such as NumLWeapons.


		itemdata SpikeBoots = Game->LoadItemData(I_BOOTS); // The vanilla boots item, with a scripted rupee cost.
		int SideviewYCheckModify;	// Is 9 if Sideview, 0 if not.

		bool FallSound;		// Bool to only play SFX_PLAYERFALL once per fall.

		int FWC[2];		// Array for Moosh's "4 way curse" walking script.

		Game->MCounter[CR_LINKSTUN] = 65535;

		bool GettingHurt;	// Bool to only play hurt noises once per hit.

		
		// Strings for Mode settings
		int ModeMenu[8];	// Used to turn on / off the mode settings menu.
		int MODE_MUSICFILE[11]="MUSIC FILE";
		int MODE_MUSICTRACK[22]="MUSIC TRACK (B-UNDO)";
		int MODE_EASYWALK[11]="8 WAY WALK";
		int MODE_SHIELD[7] = "SHIELD";
		int MODE_HEARTRING[17]="AUTO LIFE REFILL";
		int MODE_STARTHEARTS[21]="FULL STARTING HEARTS";
		int MODE_NOHEARTS[15]="NO HEART DROPS";
		int MODE_TOUGHMONSTERS[17]="TOUGHER MONSTERS";
		int MODE_ZAPPER[22]="ZAPPER (MOUSE + RUPY)";
		int MODE_BOWWOW[8]="BOW-WOW";
		int MODE_LINK[13]="LINK COSTUME";
		int MODE_ON[4]="ON";
		int MODE_OFF[4]="OFF";
		int MUSICNAME_BUFFER[256];
		int MUSICNAME_COMPARE[256];
		int MUSICNAME_UNDOBUFFER[256];
		int MUSICNAME_BLANK[1];
		int MODE_LABEL[6]="MODE-";







// ---------------------------------------  Chapter 2: First actions (before While)


// Load current undo track upon startup
		ModeMenu[UNDO_MUSICTRACK] = Game->GetDMapMusicTrack(Game->GetCurDMap());
		Game->GetDMapMusicFilename(Game->GetCurDMap(), MUSICNAME_UNDOBUFFER);


// Link Costume mode effect is re-set upon continue
		if (Link->Item[I_LINKCOSTUME])
		{
			CopyTileRow(LINKCOPY_TILE,ZELDA_TILES,180);
			CopyTileRow(LINKVICTORY_TILES,ORIGINALVICTORY_TILES,9);
		}


// Full Starting Hearts mode effect
		if (Link->Item[I_STARTHEARTS]) Link->HP = Link->MaxHP;



		DoDraw = true;










// --------------------------------------- Chapter 3: While loop begins

		while(true){
			Waitframe();











// --------	DEBUG FEATURE - REMOVE FROM RELEASE:
			Game->Cheat = 4;







// --------------------------------------- Chapter 4: Prevent rupoor underflow
			if (Game->Counter[CR_RUPEES] == 65535) Game->Counter[CR_RUPEES] = 0;





// --------------------------------------- Chapter 5: Link (Zelda) is stunned
			if (Game->Counter[CR_LINKSTUN] > 0)
			{
				Game->Counter[CR_LINKSTUN] --;
				if (Game->Counter[CR_LINKSTUN] > 20)
				{
					 NoAction();
					Screen->FastTile(3,Link->X,Link->Y,Link->Tile,Choose(7,8),128);
				}
			}


// --------------------------------------- Chapter 6: Mode menu (start)
			if (ModeMenu[CHANGE_DMAPS] != Game->GetCurDMap())
			{
				ModeMenu[CHANGE_DMAPS] = Game->GetCurDMap();
				ModeMenu[UNDO_MUSICTRACK] = Game->GetDMapMusicTrack(Game->GetCurDMap());
				Game->GetDMapMusicFilename(Game->GetCurDMap(), MUSICNAME_UNDOBUFFER);
			}


			if (Link->PressMap)
			{
				if (ModeMenu[MODEMENU_ON] == 0)
				{
					ModeMenu[1] = 1;
					Game->GetDMapMusicFilename(Game->GetCurDMap(), MUSICNAME_BUFFER);
					ModeMenu[SELECT_MUSICTRACK] = Game->GetDMapMusicTrack(Game->GetCurDMap());
					ModeMenu[SELECT_MUSICFILE] = Game->GetCurDMap();
				}
				else ModeMenu[MODEMENU_ON] = 0;
			}
			if (ModeMenu[MODEMENU_ON] == 1)
			{
				Screen->Rectangle(
					7,	//layer
					0,	//start X
					-56,	//start y
					256,	//end x
					31,	//end y
					0,1,0,0,0,true,128);

			//--- Switches the settings
				if (Link->PressDown)
				{
					if (ModeMenu[SELECT_MODE] < 10) ModeMenu[SELECT_MODE] ++;
					else ModeMenu[SELECT_MODE] = 0;
				}
				if (Link->PressUp)
				{ 
					if (ModeMenu[SELECT_MODE] > 0) ModeMenu[SELECT_MODE] --;
					else ModeMenu[SELECT_MODE] = 10;
				}


			//--- Music File setting


				// --- Undo last choice on current dmap
				if (Link->PressB)
				{
					ModeMenu[SELECT_MUSICTRACK] = ModeMenu[UNDO_MUSICTRACK];
					ModeMenu[SELECT_MUSICFILE] = ModeMenu[UNDO_MUSICFILE];
					Game->PlayEnhancedMusic(MUSICNAME_UNDOBUFFER,ModeMenu[UNDO_MUSICTRACK]);
					Game->SetDMapEnhancedMusic(Game->GetCurDMap(),MUSICNAME_UNDOBUFFER,ModeMenu[UNDO_MUSICTRACK]);
					Game->GetDMapMusicFilename(Game->GetCurDMap(), MUSICNAME_BUFFER);
				}



				if (ModeMenu[SELECT_MODE] == 0)
				{
					Screen->DrawString(7, 8, -56, FONT_Z1, 1, 0, TF_NORMAL, MODE_MUSICFILE, OP_OPAQUE);
					Screen->DrawString(7, 244, -56, FONT_Z1, 1, -1, TF_RIGHT, MUSICNAME_BUFFER, OP_OPAQUE);

					if (Link->PressRight)
					{
						for(ForTimer = ModeMenu[SELECT_MUSICFILE]; ForTimer < 511; ForTimer++)
						{
							Game->GetDMapMusicFilename(ForTimer, MUSICNAME_COMPARE);
							if(strcmp(MUSICNAME_COMPARE,MUSICNAME_BUFFER) && MUSICNAME_COMPARE > 0 && strcmp(MUSICNAME_COMPARE,MUSICNAME_BLANK))
							{
								Game->GetDMapMusicFilename(ForTimer, MUSICNAME_BUFFER);
								ModeMenu[SELECT_MUSICFILE] = ForTimer;
								ModeMenu[SELECT_MUSICTRACK] = 1;
								Game->PlayEnhancedMusic(MUSICNAME_COMPARE,1);
								Game->SetDMapEnhancedMusic(Game->GetCurDMap(),MUSICNAME_COMPARE,1);
								break;
							}
						}
					}
					if (Link->PressLeft)
					{
						for(ForTimer = ModeMenu[SELECT_MUSICFILE]; ForTimer > 0; ForTimer--)
						{
							Game->GetDMapMusicFilename(ForTimer, MUSICNAME_COMPARE);
							if (strcmp(MUSICNAME_COMPARE,MUSICNAME_BUFFER))
							{
								if(MUSICNAME_COMPARE[0] && MUSICNAME_COMPARE[0] != ' ')
								{
									
									Game->GetDMapMusicFilename(ForTimer, MUSICNAME_BUFFER);
									Game->PlayEnhancedMusic(MUSICNAME_BUFFER,1);
									Game->SetDMapEnhancedMusic(Game->GetCurDMap(),MUSICNAME_BUFFER,1);
									ModeMenu[SELECT_MUSICFILE] = ForTimer;
									ModeMenu[SELECT_MUSICTRACK] = 1;
									break;
								}
							}
						}
					}
				}
				else
				{
					Screen->DrawString(7, 8, -56, FONT_Z1, 2, 0, TF_NORMAL, MODE_MUSICFILE, OP_OPAQUE);
					Screen->DrawString(7, 244, -56, FONT_Z1, 2, 0, TF_RIGHT, MUSICNAME_BUFFER, OP_OPAQUE);
				}





			//--- Music Track setting
				if (ModeMenu[SELECT_MODE] == 1)
				{
					Screen->DrawString(7, 8, -48, FONT_Z1, 1, 0, TF_NORMAL, MODE_MUSICTRACK, OP_OPAQUE);
					Screen->DrawInteger(
						7,					//int layer, 
						208,					//int x, 
						-48,					//int y, 
						FONT_Z1,				//int font, 
						1,					//int color, 
						0,					//int background_color, 
						-1,					//int width, 
						-1,					//int height, 
						ModeMenu[SELECT_MUSICTRACK],		//int number, 
						0, 					//int number_decimal_places, 
						128);					 //int opacity
					if (Link->PressRight)
					{
						ModeMenu[SELECT_MUSICTRACK] ++;
						Game->PlayEnhancedMusic(MUSICNAME_BUFFER,ModeMenu[SELECT_MUSICTRACK]);
						Game->SetDMapEnhancedMusic(Game->GetCurDMap(),MUSICNAME_BUFFER,ModeMenu[SELECT_MUSICTRACK]);
					}
					if (Link->PressLeft)
					{	
						ModeMenu[SELECT_MUSICTRACK] --;
						Game->PlayEnhancedMusic(MUSICNAME_BUFFER,ModeMenu[SELECT_MUSICTRACK]);
						Game->SetDMapEnhancedMusic(Game->GetCurDMap(),MUSICNAME_BUFFER,ModeMenu[SELECT_MUSICTRACK]);
					}
				}
				else
				{
					Screen->DrawString(7, 8, -48, FONT_Z1, 2, 0, TF_NORMAL, MODE_MUSICTRACK, OP_OPAQUE);
					Screen->DrawInteger(
						7,					//int layer, 
						208,					//int x, 
						-48,					//int y, 
						FONT_Z1,				//int font, 
						2,					//int color, 
						0,					//int background_color, 
						-1,					//int width, 
						-1,					//int height, 
						ModeMenu[SELECT_MUSICTRACK],		//int number, 
						0, 					//int number_decimal_places, 
						128);					 //int opacity
				}




	//--- 8 Way Walk setting
	// See "FourWayCurse()" function above
				if (ModeMenu[SELECT_MODE] == 2)
				{
					Screen->DrawString(7, 8, -40, FONT_Z1, 8, 0, TF_NORMAL, MODE_EASYWALK, OP_OPAQUE);
					if (Link->Item[I_PROGRESSIVEGEAR])
					{
						Screen->DrawString(7, 208, -40, FONT_Z1, 8, 0, TF_NORMAL, MODE_ON, OP_OPAQUE);	
						Screen->FastTile(7,236,-40,GEAR_TILE,0,128);
					}
					else Screen->DrawString(7, 208, -40, FONT_Z1, 8, 0, TF_NORMAL, MODE_OFF, OP_OPAQUE);
					if (Link->PressRight || Link->PressLeft)
					{
						if (Link->Item[I_PROGRESSIVEGEAR])
						{
							Link->Item[I_PROGRESSIVEGEAR] = false;
							Game->PlaySound(SFX_MODEOFF);
						}
						else
						{
							Link->Item[I_PROGRESSIVEGEAR] = true;
							Game->PlaySound(SFX_MODEON);
						}
					}
				}
				else
				{
					Screen->DrawString(7, 8, -40, FONT_Z1, 7, 0, TF_NORMAL, MODE_EASYWALK, OP_OPAQUE);
					if (Link->Item[I_PROGRESSIVEGEAR])
					{
						Screen->DrawString(7, 208, -40, FONT_Z1, 7, 0, TF_NORMAL, MODE_ON, OP_OPAQUE);	
						Screen->FastTile(7,236,-40,GEAR_TILE,0,128);
					}
					else Screen->DrawString(7, 208, -40, FONT_Z1, 7, 0, TF_NORMAL, MODE_OFF, OP_OPAQUE);
				}


	//--- Shield setting
	//Effect is default Shield 1 item (93).
				if (ModeMenu[SELECT_MODE] == 3) 
				{
					Screen->DrawString(7, 8, -32, FONT_Z1, 8, 0, TF_NORMAL, MODE_SHIELD, OP_OPAQUE);
					if (Link->Item[I_SHIELD1]){
						Screen->DrawString(7, 208, -32, FONT_Z1, 8, 0, TF_NORMAL, MODE_ON, OP_OPAQUE);	
						Screen->FastTile(7,236,-32,SHIELD1_TILE,6,128);
					}	
					else Screen->DrawString(7, 208, -32, FONT_Z1, 8, 0, TF_NORMAL, MODE_OFF, OP_OPAQUE);	
					if (Link->PressRight || Link->PressLeft)
					{
						if (Link->Item[I_SHIELD1])
						{
							Link->Item[I_SHIELD1] = false;
							Game->PlaySound(SFX_MODEOFF);
						}
						else
						{
							Link->Item[I_SHIELD1] = true;
							Game->PlaySound(SFX_MODEON);
						}
					}
				}
				else
				{
					Screen->DrawString(7, 8, -32, FONT_Z1, 7, 0, TF_NORMAL, MODE_SHIELD, OP_OPAQUE);
					if (Link->Item[I_SHIELD1]){
						Screen->DrawString(7, 208, -32, FONT_Z1, 7, 0, TF_NORMAL, MODE_ON, OP_OPAQUE);
						Screen->FastTile(7,236,-32,SHIELD1_TILE,6,128);
					}
					else Screen->DrawString(7, 208, -32, FONT_Z1, 7, 0, TF_NORMAL, MODE_OFF, OP_OPAQUE);	
				}






	//--- Auto Life Refill setting
	//Effect is default Heart Ring item (112).
				if (ModeMenu[SELECT_MODE] == 4) 
				{
					Screen->DrawString(7, 8, -24, FONT_Z1, 8, 0, TF_NORMAL, MODE_HEARTRING, OP_OPAQUE);
					if (Link->Item[I_HEARTRING1]){
						Screen->DrawString(7, 208, -24, FONT_Z1, 8, 0, TF_NORMAL, MODE_ON, OP_OPAQUE);	
						Screen->FastTile(7,236,-24,AUTOLIFE_TILE,0,128);
					}	
					else Screen->DrawString(7, 208, -24, FONT_Z1, 8, 0, TF_NORMAL, MODE_OFF, OP_OPAQUE);	
					if (Link->PressRight || Link->PressLeft)
					{
						if (Link->Item[I_HEARTRING1])
						{
							Link->Item[I_HEARTRING1] = false;
							Game->PlaySound(SFX_MODEOFF);
						}
						else
						{
							Link->Item[I_HEARTRING1] = true;
							Game->PlaySound(SFX_MODEON);
						}
					}
				}
				else
				{
					Screen->DrawString(7, 8, -24, FONT_Z1, 7, 0, TF_NORMAL, MODE_HEARTRING, OP_OPAQUE);
					if (Link->Item[I_HEARTRING1]){
						Screen->DrawString(7, 208, -24, FONT_Z1, 7, 0, TF_NORMAL, MODE_ON, OP_OPAQUE);
						Screen->FastTile(7,236,-24,AUTOLIFE_TILE,0,128);
					}
					else Screen->DrawString(7, 208, -24, FONT_Z1, 7, 0, TF_NORMAL, MODE_OFF, OP_OPAQUE);	
				}




	//--- Full Starting Hearts setting
	//See "Full Starting Hearts effect" above, before While.
				if (ModeMenu[SELECT_MODE] == 5) 
				{
					Screen->DrawString(7, 8, -16, FONT_Z1, 8, 0, TF_NORMAL, MODE_STARTHEARTS, OP_OPAQUE);
					if (Link->Item[I_STARTHEARTS]){
						Screen->DrawString(7, 208, -16, FONT_Z1, 8, 0, TF_NORMAL, MODE_ON, OP_OPAQUE);	
						Screen->FastTile(7,236,-16,STARTHEARTS_TILE,1,128);
					}	
					else Screen->DrawString(7, 208, -16, FONT_Z1, 8, 0, TF_NORMAL, MODE_OFF, OP_OPAQUE);	
					if (Link->PressRight || Link->PressLeft)
					{
						if (Link->Item[I_STARTHEARTS])
						{
							Link->Item[I_STARTHEARTS] = false;
							Game->PlaySound(SFX_MODEOFF);
						}
						else
						{
							Link->Item[I_STARTHEARTS] = true;
							Game->PlaySound(SFX_MODEON);
						}
					}
				}
				else
				{
					Screen->DrawString(7, 8, -16, FONT_Z1, 7, 0, TF_NORMAL, MODE_STARTHEARTS, OP_OPAQUE);
					if (Link->Item[I_STARTHEARTS]){
						Screen->DrawString(7, 208, -16, FONT_Z1, 7, 0, TF_NORMAL, MODE_ON, OP_OPAQUE);
						Screen->FastTile(7,236,-16,STARTHEARTS_TILE,1,128);
					}
					else Screen->DrawString(7, 208, -16, FONT_Z1, 7, 0, TF_NORMAL, MODE_OFF, OP_OPAQUE);	
				}







	//--- No Heart Drops setting
	//See "No Heart Drops effect" below
				if (ModeMenu[SELECT_MODE] == 6) 
				{
					Screen->DrawString(7, 8, -8, FONT_Z1, 4, 0, TF_NORMAL, MODE_NOHEARTS, OP_OPAQUE);
					if (Link->Item[I_NOHEARTS])
					{
						Screen->DrawString(7, 208, -8, FONT_Z1, 4, 0, TF_NORMAL, MODE_ON, OP_OPAQUE);
						Screen->FastTile(7,236,-8,NOHEART_TILE,0,128);	
					}
					else Screen->DrawString(7, 208, -8, FONT_Z1, 4, 0, TF_NORMAL, MODE_OFF, OP_OPAQUE);
					if (Link->PressRight || Link->PressLeft)
					{
						if (Link->Item[I_NOHEARTS])
						{
							Link->Item[I_NOHEARTS] = false;
							Game->PlaySound(SFX_MODEOFF);
						}
						else
						{
							Link->Item[I_NOHEARTS] = true;
							Game->PlaySound(SFX_MODEON);
						}
					}		
				}
				else
				{
					 Screen->DrawString(7, 8, -8, FONT_Z1, 9, 0, TF_NORMAL, MODE_NOHEARTS, OP_OPAQUE);
					if (Link->Item[I_NOHEARTS])
					{
						Screen->DrawString(7, 208, -8, FONT_Z1, 9, 0, TF_NORMAL, MODE_ON, OP_OPAQUE);
						Screen->FastTile(7,236,-8,NOHEART_TILE,0,128);	
					}
					else Screen->DrawString(7, 208, -8, FONT_Z1, 9, 0, TF_NORMAL, MODE_OFF, OP_OPAQUE);		
				}




	//---Tougher Monsters setting
	//see "Tougher Monsters effect" below
				if (ModeMenu[SELECT_MODE] == 7)
				{
					Screen->DrawString(7, 8, 0, FONT_Z1, 4, 0, TF_NORMAL, MODE_TOUGHMONSTERS, OP_OPAQUE);
					if (Link->Item[I_TOUGHMONSTERS]){
						Screen->DrawString(7, 208, 0, FONT_Z1, 4, 0, TF_NORMAL, MODE_ON, OP_OPAQUE);	
						Screen->FastTile(7,236,0,TOUGHER_TILE,0,128);	
					}
					else Screen->DrawString(7, 208, 0, FONT_Z1, 4, 0, TF_NORMAL, MODE_OFF, OP_OPAQUE);
					if (Link->PressRight || Link->PressLeft)
					{
						if (Link->Item[I_TOUGHMONSTERS])
						{
							Link->Item[I_TOUGHMONSTERS] = false;
							Game->PlaySound(SFX_MODEOFF);
						}
						else
						{
							Link->Item[I_TOUGHMONSTERS] = true;
							Game->PlaySound(SFX_MODEON);
						}
					}		
				}
				else
				{
					Screen->DrawString(7, 8, 0, FONT_Z1, 9, 0, TF_NORMAL, MODE_TOUGHMONSTERS, OP_OPAQUE);
					if (Link->Item[I_TOUGHMONSTERS]){
						Screen->DrawString(7, 208, 0, FONT_Z1, 9, 0, TF_NORMAL, MODE_ON, OP_OPAQUE);
						Screen->FastTile(7,236,0,TOUGHER_TILE,0,128);
					}
					else Screen->DrawString(7, 208, 0, FONT_Z1, 9, 0, TF_NORMAL, MODE_OFF, OP_OPAQUE);		
				}



	//---Zapper setting
	//see "Item: Duck Zapper" below
				if (ModeMenu[SELECT_MODE] == 8)
				{
					Screen->DrawString(7, 8, 8, FONT_Z1, 11, 0, TF_NORMAL, MODE_ZAPPER, OP_OPAQUE);
					if (Link->Item[I_ZAPPER])
					{
						Screen->DrawString(7, 208, 8, FONT_Z1, 11, 0, TF_NORMAL, MODE_ON, OP_OPAQUE);
						Screen->FastTile(7,236,8,DUCK_TILE,0,128);
					}
					else Screen->DrawString(7, 208, 8, FONT_Z1, 11, 0, TF_NORMAL, MODE_OFF, OP_OPAQUE);	
					if (Link->PressRight || Link->PressLeft)
					{
						if (Link->Item[I_ZAPPER])
						{
							Link->Item[I_ZAPPER] = false;
							Game->PlaySound(SFX_MODEOFF);
						}
						else
						{
							Link->Item[I_ZAPPER] = true;
							Game->PlaySound(SFX_MODEON);
						}
					}	
				}
				else
				{
					Screen->DrawString(7, 8, 8, FONT_Z1, 10, 0, TF_NORMAL, MODE_ZAPPER, OP_OPAQUE);
					if (Link->Item[I_ZAPPER])
					{
						Screen->DrawString(7, 208, 8, FONT_Z1, 10, 0, TF_NORMAL, MODE_ON, OP_OPAQUE);
						Screen->FastTile(7,236,8,DUCK_TILE,0,128);
					}
					else Screen->DrawString(7, 208, 8, FONT_Z1, 10, 0, TF_NORMAL, MODE_OFF, OP_OPAQUE);		
				}

	//---Bow-Wow setting
	//see "Item: Bow-Wow" below
				if (ModeMenu[SELECT_MODE] == 9)
				{
					Screen->DrawString(7, 8, 16, FONT_Z1, 11, 0, TF_NORMAL, MODE_BOWWOW, OP_OPAQUE);
					if (Link->Item[I_BOWWOW])
					{
						Screen->DrawString(7, 208, 16, FONT_Z1, 11, 0, TF_NORMAL, MODE_ON, OP_OPAQUE);
						Screen->FastTile(7,236,16,BOWWOW_TILE,0,128);
					}
					else Screen->DrawString(7, 208, 16, FONT_Z1, 11, 0, TF_NORMAL, MODE_OFF, OP_OPAQUE);	
					if (Link->PressRight || Link->PressLeft)
					{
						if (Link->Item[I_BOWWOW])
						{
							Link->Item[I_BOWWOW] = false;
							Game->PlaySound(SFX_MODEOFF);
						}
						else
						{
							Link->Item[I_BOWWOW] = true;
							Game->PlaySound(SFX_MODEON);
						}
					}	
				}
				else
				{
					Screen->DrawString(7, 8, 16, FONT_Z1, 10, 0, TF_NORMAL, MODE_BOWWOW, OP_OPAQUE);
					if (Link->Item[I_BOWWOW])
					{
						Screen->DrawString(7, 208, 16, FONT_Z1, 10, 0, TF_NORMAL, MODE_ON, OP_OPAQUE);
						Screen->FastTile(7,236,16,BOWWOW_TILE,0,128);
					}
					else Screen->DrawString(7, 208, 16, FONT_Z1, 10, 0, TF_NORMAL, MODE_OFF, OP_OPAQUE);		
				}

	//---Link Costume setting
	//see "Item: Link Costume" above, before While
				if (ModeMenu[SELECT_MODE] == 10)
				{
					Screen->DrawString(7, 8, 24, FONT_Z1, 11, 0, TF_NORMAL, MODE_LINK, OP_OPAQUE);
					if (Link->Item[I_LINKCOSTUME])
					{
						Screen->DrawString(7, 208, 24, FONT_Z1, 11, 0, TF_NORMAL, MODE_ON, OP_OPAQUE);
						Screen->FastTile(7,236,24,LINKCOSTUME_TILE,6,128);
					}
					else Screen->DrawString(7, 208, 24, FONT_Z1, 11, 0, TF_NORMAL, MODE_OFF, OP_OPAQUE);	
					if (Link->PressRight || Link->PressLeft)
					{
						if (Link->Item[I_LINKCOSTUME])
						{
							Link->Item[I_LINKCOSTUME] = false;
							Game->PlaySound(SFX_MODEOFF);
							CopyTileRow(ZELDACOPY_TILE,ZELDA_TILES,180);
							CopyTileRow(ZELDAVICTORY_TILES,ORIGINALVICTORY_TILES,9);
							StoodStill = 0;
						}
						else
						{
							Link->Item[I_LINKCOSTUME] = true;
							Game->PlaySound(SFX_MODEON);
							CopyTileRow(LINKCOPY_TILE,ZELDA_TILES,180);
							CopyTileRow(LINKVICTORY_TILES,ORIGINALVICTORY_TILES,9);
							StoodStill = 0;
						}
					}	
				}
				else
				{
					Screen->DrawString(7, 8, 24, FONT_Z1, 10, 0, TF_NORMAL, MODE_LINK, OP_OPAQUE);
					if (Link->Item[I_LINKCOSTUME])
					{
						Screen->DrawString(7, 208, 24, FONT_Z1, 10, 0, TF_NORMAL, MODE_ON, OP_OPAQUE);
						Screen->FastTile(7,236,24,LINKCOSTUME_TILE,6,128);
					}
					else Screen->DrawString(7, 208, 24, FONT_Z1, 10, 0, TF_NORMAL, MODE_OFF, OP_OPAQUE);		
				}

	// --- end of modes
				NoAction();
			}

	// --- Link costume grunts
		if (Link->Action == LA_GOTHURTLAND)
		{
			if (!GettingHurt)
			{
				if (Link->Item[I_LINKCOSTUME])
				{
					Game->PlaySound(SFX_LINKHURT);
					GettingHurt = true;
				}
				else
				{
					Game->PlaySound(SFX_ZELDAHURT);
					GettingHurt = true;
				}
			}
		}
		else if (GettingHurt) GettingHurt = false;



	// --- Draw word "Mode" if modes are enabled

// --------------------------------------- Chapter 6: Mode menu (end)









// --------------------------------------- Chapter 7: Link drowns, but only in Sideview 
// (Note: The "Link drowns in walkable water" quest rule is off)
			if (IsSideview())
			{
				if (Screen->ComboT[ComboAt(Link->X+7,Link->Y+12)] == CT_WATER) Link->Action = LA_DROWNING;
			}








// --------------------------------------- Chapter 8: Sideview Ladder combos (start)

			if (Screen->ComboT[ComboAt(Link->X+4,Link->Y+8)] == CT_SIDECLIMB || Screen->ComboT[ComboAt(Link->X+4,Link->Y+16)] == CT_SIDECLIMB || Screen->ComboT[ComboAt(Link->X+12,Link->Y+8)] == CT_SIDECLIMB || Screen->ComboT[ComboAt(Link->X+12,Link->Y+16)] == CT_SIDECLIMB)
			{
				Link->Jump = 0;
				if (Link->Action < 2)
				{
					if (Link->InputUp){
						if (Screen->ComboT[ComboAt(Link->X+4,Link->Y+8)] == CT_SIDECLIMB || Screen->ComboT[ComboAt(Link->X+4,Link->Y+15)] == CT_SIDECLIMB || Screen->ComboT[ComboAt(Link->X+12,Link->Y+8)] == CT_SIDECLIMB || Screen->ComboT[ComboAt(Link->X+12,Link->Y+15)] == CT_SIDECLIMB)
						{
							PushLink(DIR_UP);
							if (Link->Y <2) Link->Y --; 
						}
					}
					if (Link->InputDown) 
						{
							PushLink(DIR_DOWN);
							if (Link->Y > 158) Link->Y ++;
						}
				}
			}

// --------------------------------------- Chapter 8: Sideview Ladder combos (end)






// --------------------------------------- Chapter 9: Spike-walking boots drain rupees slowly (start)

			if (!Link->Item[I_BOOTSTWO] && Link->Z == 0)
			{
				if (Game->Counter[CR_RUPEES] > 0)
				{
					if (SpikeBoots->Power == 0) SpikeBoots->Power = 7;
					if (IsSideview()) SideviewYCheckModify = 9;
					else if (SideviewYCheckModify > 0) SideviewYCheckModify = 0;
					if (Screen->ComboT[ComboAt(Link->X+7,Link->Y+8+SideviewYCheckModify)] >= CT_DAMAGE1 && Screen->ComboT[ComboAt(Link->X+7,Link->Y+8+SideviewYCheckModify)] <= CT_DAMAGE4 || Screen->ComboT[ComboAt(Link->X+7,Link->Y+8+SideviewYCheckModify)] >= CT_DAMAGE5 && Screen->ComboT[ComboAt(Link->X+7,Link->Y+8+SideviewYCheckModify)] <= CT_DAMAGE7)					{

						if (SpikeBootsTimer == 0)
						{
							StoodStill = 0;
							Game->DCounter[CR_RUPEES] --;
							SpikeBootsTimer = 32;
						}
						else SpikeBootsTimer --;
					}
				}
				else if (SpikeBoots->Power == 7) SpikeBoots->Power = 0;
			}

// --------------------------------------- Chapter 9: Spike-walking boots drain rupees slowly (end)








// --------------------------------------- Chapter 10: Item: Medicine (Start)
			if (Link->HP == 0)
			{
				if (Link->Item[I_REDMEDICINE])
				{
					Game->PlaySound(25);
					Link->HP = 1;
					Game->DCounter[CR_LIFE] = Link->MaxHP;
					Link->Item[I_REDMEDICINE] = false;
				}
				else if (Link->Item[I_BLUEMEDICINE])
				{
					Game->PlaySound(25);
					Link->HP = 1;
					Game->DCounter[CR_LIFE] = Link->MaxHP;
					Link->Item[I_BLUEMEDICINE] = false;
				}
			}
// --------------------------------------- Chapter 10: Item: Medicine (End)





// --------------------------------------- Chapter 11: Item: Hiding Shellmet (Start)
			if (DoDraw)
			{
				if (Link->InputUp || Link->InputDown || Link->InputLeft || Link->InputRight || Link->PressB || Link->PressA || Link->Action >LA_NONE)
				{
					if (StoodStill > 0) StoodStill --;
					if (StoodStill > 3) StoodStill = StoodStill - 2;
					if (StoodStill > 105) StoodStill = StoodStill - 2;
					if (ShellmetOn)
					{
						Link->CollDetection = 1;
						ShellmetOn = false;
					}
				}
				else if (StoodStill < 120 && !Link->InputB && !Link->InputA && DigDelay == 0 && Game->Counter[CR_LINKSTUN] <= 20) StoodStill ++;
				if (StoodStill >= 120)
				{
					if (Link->Item[I_SHELLMET])
					{
						if (DoDraw) Screen->FastTile(4, Link->X, Link->Y-Link->Z-3, SHELLMET_TILE,6,128);
						if (!ShellmetOn)
						{
							ShellmetOn = true;
							Link->CollDetection = 0;
						}
					}
				}
			}
// --------------------------------------- Chapter 11: Item: Hiding Shellmet (End)






// --------------------------------------- Chapter 12: Item: Guardian Acorn (Start)
			if (Game->Counter[CR_ACORNS] > 0)
			{
				if (!Link->Item[I_ACORNBLUE]) Link->Item[I_ACORNBLUE] = true;
				if (Game->Counter[CR_ACORNS] > 24)
				{
					if (!Link->Item[I_ACORNRED]) Link->Item[I_ACORNRED] = true;
				}
				else if (Link->Item[I_ACORNRED]) Link->Item[I_ACORNRED] = false;
			}
			if (Game->Counter[CR_ACORNS] == 0)
			{
				if (Link->Item[I_ACORNRED]) Link->Item[I_ACORNRED] = false;
				if (Link->Item[I_ACORNBLUE]) Link->Item[I_ACORNBLUE] = false;
			}
			if (!BeingHurt)
			{
				if (Link->Action == LA_GOTHURTLAND)
				{
					BeingHurt = true;
					if (Game->Counter[CR_ACORNS] > 0) Game->Counter[CR_ACORNS] --;
					if (Game->Counter[CR_ACORNS] == 0) Link->Item[I_GUARDIANACORN] = false;
				}
			}
			else
			{
				if (Link->Action != LA_GOTHURTLAND) BeingHurt = false;
			}



// --------------------------------------- Chapter 12: Item: Guardian Acorn (End)





// --------------------------------------- Chapter 13: Item: Duck Zapper (start)

	
			if (Link->Item[I_ZAPPER] && DoDraw)
			{
				Screen->FastCombo(7,Link->InputMouseX,Link->InputMouseY,COMBO_DUCK,6,128);
				Screen->FastCombo(7,Link->InputMouseX+16,Link->InputMouseY,COMBO_DUCK+1,6,128);
				Screen->FastCombo(7,Link->InputMouseX,Link->InputMouseY+16,COMBO_DUCK+4,6,128);
				Screen->FastCombo(7,Link->InputMouseX+16,Link->InputMouseY+16,COMBO_DUCK+5,6,128);		

				if (Link->InputMouseB)
				{
					if (!HoldingMouse)
					{
						if (Game->Counter[CR_RUPEES] > 0){
							Game->Counter[CR_RUPEES] --;
							DuckDelay = 32;
						}
						HoldingMouse = true;
						Game->PlaySound(SFX_DUCK);
					}
				}
				else if (HoldingMouse && DuckDelay == 0) HoldingMouse = false;
				if (DuckDelay > 0) DuckDelay --;
				if (DuckDelay > 24){
						Screen->Rectangle(
						7,	//layer
						0,	//start X
						-56,	//start y
						256,	//end x
						176,	//end y
						0,1,0,0,0,true,128);
						Screen->Rectangle(
						7,	//layer
						Link->InputMouseX-8,	//start X
						Link->InputMouseY-8,	//start y
						Link->InputMouseX+24,	//end x
						Link->InputMouseY+24,	//end y
						1,1,0,0,0,true,128);
				}
				if (DuckDelay == 24){
 					lweapon PewPew = CreateLWeaponAt(LW_BOMBBLAST,Link->InputMouseX,Link->InputMouseY);
					PewPew->Damage = 4;
 					eweapon BlamBlam = CreateEWeaponAt(EW_BOMBBLAST,Link->InputMouseX,Link->InputMouseY);
					BlamBlam->Damage = 8;
				}
				if (Game->ClickToFreezeEnabled) Game->ClickToFreezeEnabled = false;
			}
			else if (!Game->ClickToFreezeEnabled) Game->ClickToFreezeEnabled = true;

// --------------------------------------- Chapter 13: Item: Duck Zapper (end)






// --------------------------------------- Chapter 14: Item: Bow-Wow (Start)
// Note: Bow-Wow cannot eat npcs of type NPCT_AQUAMENTUS or higher (see STD_CONSTANTS), unless they are NPCT_OTHER or NPCT_OTEHRFLOAT.
// Bow-wow also cannot eat enemies with the Superbomb defense "Block" or Superbomb defense "Ignore".
//
// If the enemy has the Superbomb defense "Ignore if <1", Bow-Wow will eat it reliably after targeting it, regardless of enemy type and without a chance of failure.

			if (!BowWow->isValid())
			{
				if (Link->Item[I_BOWWOW])
				{
					if (Link->X > 8 && Link->X < 232 && Link->Y > 8 && Link->Y < 152)
					{
						BowWow = CreateLWeaponAt(LW_BOWWOW,Link->X,Link->Y);
						BowWow->CollDetection = 0;
						BowWow->Dir = Link->Dir;
					}
				}
			}
			else
			{
				BowWow->DeadState = WDS_ALIVE;
				if (!Link->Item[I_BOWWOW]) Remove(BowWow);

				if (BowWow->Dir == DIR_UP) BowWow->UseSprite(SP_BOWWOWUP);
				if (BowWow->Dir == DIR_DOWN) BowWow->UseSprite(SP_BOWWOWDOWN);
				if (BowWow->Dir == DIR_LEFT) BowWow->UseSprite(SP_BOWWOWLEFT);
				if (BowWow->Dir == DIR_RIGHT) BowWow->UseSprite(SP_BOWWOWRIGHT);

				if (Link->Item[I_BOWWOWDETECTOR]) Screen->FastTile(6,BowWowStatus[BOWWOW_GOX],BowWowStatus[BOWWOW_GOY],22260,8,128);

				



			// Bow-wow range limit
				if (Link->Y > BowWow->Y + 40 || Link->Y < BowWow->Y - 40 || Link->X > BowWow->X + 40 || Link->X < BowWow->X - 40)
				{
					BowWowStatus[BOWWOW_GOX] = Link->X;
					BowWowStatus[BOWWOW_GOY] = Link->Y;
					BowWowStatus[BOWWOW_TIMER] = 16;
					if (Link->Y > BowWow->Y + 40) BowWow->Y = Link->Y - 40;
					if (Link->Y < BowWow->Y - 40) BowWow->Y = Link->Y + 40;
					if (Link->X > BowWow->X + 40) BowWow->X = Link->X - 40;
					if (Link->X < BowWow->X - 40) BowWow->X = Link->X + 40;
				}

			// Bow-wow changes direction
				if (BowWowStatus[BOWWOW_TIMER] == 0)
				{
					BowWowStatus[BOWWOW_GOX] = Rand(Link->X-40,Link->X+40);
					BowWowStatus[BOWWOW_GOY] = Rand(Link->Y-40,Link->Y+40);
					BowWowStatus[BOWWOW_TIMER] = Rand(80.511);
				}
				else
				{
					BowWowStatus[BOWWOW_TIMER] --;


			// Bow-wow moves					

					if (BowWow->X > BowWowStatus[BOWWOW_GOX])
					{
						if (BowWow->X > 8 && BowWow->X > Link->X-39) BowWow->X --;
						BowWow->Dir = DIR_LEFT;
					}
					else if (BowWow->X < BowWowStatus[BOWWOW_GOX])
					{
						if (BowWow->X < 232 && BowWow->X < Link->X+39) BowWow->X ++;
						BowWow->Dir = DIR_RIGHT;
					}
					if (BowWow->Y > BowWowStatus[BOWWOW_GOY])
					{
						if (BowWow->Y > 8 && BowWow->Y > Link->Y-39) BowWow->Y --;
						BowWow->Dir = DIR_UP;
					}
					else if (BowWow->Y < BowWowStatus[BOWWOW_GOY])
					{
						if (BowWow->Y < 152 && BowWow->X < Link->X+39) BowWow->Y ++;
						BowWow->Dir = DIR_DOWN;
					}


			// Bow-Wow falls
					if (IsSideview())
					{
						if (BowWowStatus[BOWWOW_GOY] < Link->Y - 20) BowWowStatus[BOWWOW_GOY] = Link->Y - 20; 
						if (BowWow->Y == BowWowStatus[BOWWOW_GOY] && BowWowStatus[BOWWOW_GOY] < Link->Y)
						{
							if (CanWalk(BowWow->X,BowWow->Y,DIR_DOWN,1,false))
							{
								BowWowStatus[BOWWOW_GOY] = Link->Y;
								if (BowWowStatus[BOWWOW_TIMER] < 50) BowWowStatus[BOWWOW_TIMER] = 50;
							}
						}
					}
			// Bow-wow bounces
					else
					{
						if (BowWowStatus[BOWWOW_BOUNCE] > 0)
						{
							BowWowStatus[BOWWOW_BOUNCE] --;
							BowWow->DrawYOffset --;
							BowWow->HitYOffset --;
						}
						else if (BowWow->DrawYOffset < 0)
						{
							BowWow->DrawYOffset ++;
							BowWow->HitYOffset ++;							
						}
						else BowWowStatus[BOWWOW_BOUNCE] = Choose(0,0,0,0,0,Choose(0,0,Rand(8,16)));
					}
				}



			// Bow-wow's chain
				Screen->FastTile(
					1, 
					Link->X+((BowWow->X - Link->X) / 2), 
					Link->Y+((BowWow->Y - Link->Y) / 2) - (Link->Z/2)+BowWow->DrawYOffset/1.5, 
					BOWWOWCHAIN_TILE, BowWow->CSet, 128);
				Screen->FastTile(
					1, 
					Link->X+((BowWow->X - Link->X) / 3.75), 
					Link->Y+((BowWow->Y - Link->Y) / 3.75) - Link->Z +BowWow->DrawYOffset/2, 
					BOWWOWCHAIN_TILE, BowWow->CSet, 128);
				Screen->FastTile(
					1, 
					Link->X+((BowWow->X - Link->X) / 1.35), 
					Link->Y+((BowWow->Y - Link->Y) / 1.35) - (Link->Z/3)+BowWow->DrawYOffset, 
					BOWWOWCHAIN_TILE, BowWow->CSet, 128);



			// Bow-wow eats combos such as gopongo flowers
				if (Screen->ComboF[ComboAt(BowWow->X+7,BowWow->Y+8)] == CF_BOWWOW || Screen->ComboI[ComboAt(BowWow->X+7,BowWow->Y+8)] == CF_BOWWOW)
				{
					Screen->ComboD[ComboAt(BowWow->X+7,BowWow->Y+8)] = Screen->UnderCombo;
					Screen->ComboF[ComboAt(BowWow->X+7,BowWow->Y+8)] = 0;
					Game->PlaySound(SFX_EDEAD);
				}


			// Bow-wow targets bait
				if (NumLWeaponsOf(LW_BAIT) > 0)
				{
					if (randoLW->ID != LW_BAIT) randoLW = LoadLWeaponOf(LW_BAIT);
					else
					{
						BowWowStatus[BOWWOW_GOX] = randoLW->X;
						BowWowStatus[BOWWOW_GOY] = randoLW->Y;
					}
				}

			// Bow-wow targets enemies
				if (BowWowStatus[BOWWOW_EAT] == 0) BowWowStatus[BOWWOW_EAT] = Rand(200,800);
				else
				{
					BowWowStatus[BOWWOW_EAT] --;
					if (BowWowStatus[BOWWOW_EAT] == 1)
					{
						if (Screen->NumNPCs() > 0)
						{
							BowWowTarget = Screen->LoadNPC(Rand(Screen->NumNPCs()));
							if (BowWowTarget->X < Link->X + 40 && BowWowTarget->X > Link->X - 40 && BowWowTarget->Y < Link->Y + 40 && BowWowTarget->Y > Link->Y - 40)
							{
								BowWowStatus[BOWWOW_GOX] = BowWowTarget->X;
								BowWowStatus[BOWWOW_GOY] = BowWowTarget->Y;
								BowWowStatus[BOWWOW_TIMER] = 320;
								Game->PlaySound(SFX_BOWWOW);
								BowWowStatus[BOWWOW_EAT] = 0;
							}
							else BowWowStatus[BOWWOW_EAT] = 2;
						}
						else BowWowStatus[BOWWOW_EAT] = 0;
					}
				}
			// Bow-wow eats enemies
				if (BowWowTarget->isValid())
				{
					if (Collision(BowWow,BowWowTarget))
					{
						if (BowWowTarget->Defense[NPCD_SBOMB] != NPCDT_BLOCK)
						{
							if (BowWowTarget->Type < NPCT_AQUAMENTUS && BowWowTarget->Type != NPCT_GUY || BowWowTarget->Type >= NPCT_OTHERFLOAT) BowWowTarget->HP = Choose(BowWowTarget->HP,BowWowTarget->HP,BowWowTarget->HP,BowWowTarget->HP,BowWowTarget->HP,0);
							if (BowWowTarget->Defense[NPCD_SBOMB] == NPCDT_IGNORE1) BowWowTarget->HP = 0;
						}
						if (BowWowTarget->Defense[NPCD_SBOMB] == NPCDT_IGNORE) BowWowTarget->HP = 0;
					}
				}
			}
// --------------------------------------- Chapter 14: Item: Bow-Wow (End)






// --------------------------------------- Chapter 15: Every-frame Item checks / for loop of Items (start)

			for(ForTimer = Screen->NumItems(); ForTimer > 0; ForTimer--)
			{

		// --- Display Rupee amount number (by using the Rupee's "Power" setting)

				item randoitem = Screen->LoadItem(ForTimer);
				if (!randoitem->isValid()) continue;
				{
					randoitemdata = Game->LoadItemData(randoitem->ID);
					if (randoitemdata->Family == IC_RUPEE)
					{
						if (randoitemdata->Power > 0)
						{

						//Draw "X"; dummied out
						//	Screen->DrawCharacter(
						//	2,					//int layer,
						//	randoitem->X+12,			//int x,
						//	randoitem->Y+8,				//int y,
						//	FONT_Z1,				//int font,
						//	1,					//int color,
						//	-1,					//int background_color,
						//	-1,					//int width,
						//	-1,					//int height,
						//	88,	//X				//int glyph,
						//	128);					//int opacity

							if (randoitem->X < 225)
							{
								Screen->DrawInteger(
								2,					//int layer, 
								randoitem->X+12,			//int x, 
								randoitem->Y+8,				//int y, 
								FONT_Z1,				//int font, 
								1,					//int color, 
								-1,					//int background_color, 
								-1,					//int width, 
								-1,					//int height, 
								randoitemdata->Power,			//int number, 
								0, 					//int number_decimal_places, 
								128);					 //int opacity
							}
							else
							{
								Screen->DrawInteger(
								2,					//int layer, 
								randoitem->X,				//int x, 
								randoitem->Y+16,			//int y, 
								FONT_Z1,				//int font, 
								1,					//int color, 
								-1,					//int background_color, 
								-1,					//int width, 
								-1,					//int height, 
								randoitemdata->Power,			//int number, 
								0, 					//int number_decimal_places, 
								128);					 //int opacity
							}
							
						}
					}


		// --- No hearts Drop effect
					if (Link->Item[I_NOHEARTS])
					{
						if (randoitem->ID == I_HEART || randoitem->ID == I_HEARTTWO) Remove(randoitem);
					}

				}
			}


// --------------------------------------- Chapter 15: Every-frame Item checks / for loop of Items (end)






// --------------------------------------- Chapter 16: Every-frame EWeapon checks / for loop of EWeapons (start)
			for(ForTimer = Screen->NumEWeapons(); ForTimer > 0; ForTimer--)
			{
				randoEW = Screen->LoadEWeapon(ForTimer);
				if(!randoEW->isValid()) continue;
				{


		// -- Slower EW_BOMB
					if (randoEW->Step > 140)
					{
						if (randoEW->ID == EW_BOMB)
						{	
							randoEW->Step = 140;
							if (randoEW->Flip != FLIP_NONE) randoEW->Flip = FLIP_NONE; //optional aesthetic thing, I like them better facing up
						}
					}

		// --- EWeapons move on conveyor belts
					if (Screen->ComboT[ComboAt(randoEW->X+7,randoEW->Y+8)] == CT_CVUP && CanWalk(randoEW->X,randoEW->Y,DIR_UP,1,false)) randoEW->Y --;
					if (Screen->ComboT[ComboAt(randoEW->X+7,randoEW->Y+8)] == CT_CVDOWN && CanWalk(randoEW->X,randoEW->Y,DIR_DOWN,1,false)) randoEW->Y ++;
					if (Screen->ComboT[ComboAt(randoEW->X+7,randoEW->Y+8)] == CT_CVLEFT && CanWalk(randoEW->X,randoEW->Y,DIR_LEFT,1,false)) randoEW->X --;
					if (Screen->ComboT[ComboAt(randoEW->X+7,randoEW->Y+8)] == CT_CVRIGHT && CanWalk(randoEW->X,randoEW->Y,DIR_RIGHT,1,false)) randoEW->X ++;


		// --- EWeapons can be destroyed by Somaria Block
					if (SomariaBlock->isValid())
					{

						if (randoEW->ID != EW_STATIONARYBOMB)
						{
							if (randoEW->X > SomariaBlock->X - 9 && randoEW->X < SomariaBlock->X + 9 && randoEW->Y > SomariaBlock->Y - 9 && randoEW->Y < SomariaBlock->Y+9)
							{
								if (randoEW->ID != EW_FIRETRAIL && randoEW->ID != EW_FIRE) 
								{
									if (randoEW->ID != EW_BOMBBLAST && randoEW->ID != EW_SBOMBBLAST && randoEW->ID != EW_FIRE2 && randoEW->ID != EW_FIREBALL2) Game->PlaySound(SFX_CLINK);
									if (randoEW->ID != EW_ROCK && randoEW->ID != EW_ARROW){
										lweapon SomariaGoesPoof = CreateLWeaponAt(LW_SPARKLE,SomariaBlock->X,SomariaBlock->Y);
										SomariaGoesPoof->UseSprite(SP_MISC_DEATH);
										Remove(SomariaBlock);
									}
								}
								if (randoEW->ID != EW_BOMBBLAST && randoEW->ID != EW_SBOMBBLAST && randoEW->ID != EW_FIRE2 && randoEW->ID != EW_FIREBALL2)
									{
										if (randoEW->ID == EW_BOMB)
										{
											eweapon Kabewm = CreateEWeaponAt(EW_BOMBBLAST,randoEW->X,randoEW->Y);
											Kabewm->Damage = randoEW->Damage;
										}
										if (randoEW->ID == EW_SBOMB)
										{
											eweapon KaBEWWWWM = CreateEWeaponAt(EW_SBOMBBLAST,randoEW->X,randoEW->Y);
											KaBEWWWWM->Damage = randoEW->Damage;
										}
										Remove(randoEW);
									}
							}
						}
					}
					

		// --- Boomerangs stun Link (Zelda)
					if (randoEW->ID == EW_BRANG)
					{
						Screen->DrawTile(
							2,
							randoEW->X,		//start X
							randoEW->Y,		//start y
							randoEW->Tile,		//tile ID
							1,			//tile width
							1,			//tile width
							Choose(6,7,8,9),	//tile cset
							-1,-1,-1,-1,0,randoEW->Flip,1,128);
						if (randoEW->DrawYOffset < 255) randoEW->DrawYOffset = 255;
						{
							if (Link->CollDetection)
							{
								if (Link->X > randoEW->X - 8 && Link->X < randoEW->X + 8 && Link->Y > randoEW->Y - 8 && Link->Y < randoEW->Y + 8)
								{
									Game->Counter[CR_LINKSTUN] = 120;
									Game->PlaySound(SFX_BRANG);
								}
							}
						}
					}

		// --- EWeapon Bolas (Guma weapon)

					if (randoEW->ID == EW_BOLA)
					{
						if (randoEW->OriginalTile != EWBOLA_ORIGINAL_TILE) 
						{
							if (randoEW->X < Link->X-32) randoEW->Dir = DIR_RIGHT;
							else if (randoEW->X > Link->X+32) randoEW->Dir = DIR_LEFT;
							else randoEW->Dir = DIR_DOWN;
							randoEW->UseSprite(SP_EWBOLA);
						}
						if (randoEW->Misc[MISC_EWBOLA]<48) randoEW->Misc[MISC_EWBOLA]++;
						if (randoEW->Misc[MISC_EWBOLA] < 16)
						{
							if (randoEW->Y > 8) randoEW->Y = randoEW->Y - 2; 
							else randoEW->Z = randoEW->Z + 2;
						}
						if (randoEW->Misc[MISC_EWBOLA] > 15 && randoEW->Misc[MISC_EWBOLA] < 32)
						{
							if (randoEW->Y > 8) randoEW->Y --;
							else randoEW->Z ++;
						}
						if (randoEW->Misc[MISC_BOLA] > 36 && randoEW->Z > 0) randoEW->Z = randoEW->Z - 2;
						if (randoEW->Misc[MISC_BOLA] > 36 && randoEW->Misc[MISC_BOLA] < 48) randoEW->Y = randoEW->Y+2;
						if (randoEW->Misc[MISC_BOLA] > 47) randoEW->Y = randoEW->Y+3;
						if (randoEW->Dir == DIR_RIGHT) randoEW->X ++;
						if (randoEW->Dir == DIR_LEFT) randoEW->X --;
					}

		// --- EWeapon Maces (Doomknocker weapon)

					if (randoEW->ID == EW_MACE)
					{
						if (randoEW->Misc[MISC_EWMACE] == 0)
						{
							randoEW->UseSprite(SP_MACE);
							randoEW->Misc[MISC_EWMACE] = 6;
							randoEW->Step = 150;
						}
						else if (randoEW->Misc[MISC_EWMACE] == 1) Remove(randoEW);


						if (randoEW->Dir == DIR_LEFT)
						{
							if (randoEW->X < 34)
							{
								if (randoEW->Angular == true) randoEW->Angular = false;
								randoEW->Dir = DIR_RIGHT;
								randoEW->Misc[MISC_EWMACE] --;
							}
						}
						if (randoEW->Dir == DIR_RIGHT)
						{
							if (randoEW->X > 206)
							{
								if (randoEW->Angular == true) randoEW->Angular = false;
								randoEW->Dir = DIR_LEFT;
								randoEW->Misc[MISC_EWMACE] --;
							}
						}
						if (randoEW->Dir == DIR_UP)
						{
							if (randoEW->Y < 34)
							{
								if (randoEW->Angular == true) randoEW->Angular = false;
								randoEW->Dir = DIR_DOWN;
								randoEW->Misc[MISC_EWMACE] --;
							}
						}
						if (randoEW->Dir == DIR_DOWN)
						{
							if (randoEW->Y > 126)
							{
								if (randoEW->Angular == true) randoEW->Angular = false;
								randoEW->Dir = DIR_UP;
								randoEW->Misc[MISC_EWMACE] --;
							}
						}
					}

		// --- EWeapon Stationary Bombs

					if (randoEW->ID == EW_STATIONARYBOMB)
					{
						if (randoEW->CollDetection != 0)
						{
							randoEW->UseSprite(SP_EWSTATIONARYBOMB);
							randoEW->CollDetection = 0;
							randoEW->Misc[MISC_STATIONARYFUSE] = 120;
						}
						else{
							randoEW->Misc[MISC_STATIONARYFUSE] --;

							// Stationary bombs which have been carried by the beetle turn into LW_BOMBs
							if (randoEW->Misc[MISC_STATIONARYFUSE] == 9998)
							{
								randoLW = CreateLWeaponAt(LW_BOMB,randoEW->X,randoEW->Y);
								//randoLW->CSet = randoEW->CSet;
								randoLW->Damage = 4;
								Remove(randoEW);
							}
						}
						if (randoEW->Misc[MISC_STATIONARYFUSE] == 1)
						{
							eweapon Kablooie = CreateEWeaponAt(EW_BOMBBLAST,randoEW->X,randoEW->Y);
							Kablooie->Damage = randoEW->Damage;
							Remove(randoEW);
						}

					}

		// --- end

				}
			}
// --------------------------------------- Chapter 16: Every-frame EWeapon checks / for loop of EWeapons (end)









// --------------------------------------- Chapter 17: Every-frame NPC checks / for loop of NPCs (start)
			for(ForTimer = Screen->NumNPCs(); ForTimer > 0; ForTimer--)
			{
				randoNPC = Screen->LoadNPC(ForTimer);
				if(!randoNPC->isValid()) continue;
				{


		// --- 2x2 big enemies
					if (randoNPC->ItemSet == IS_BIGENEMY)
					{
						if (randoNPC->Extend < 3)
						{
							randoNPC->Extend = 3;
							randoNPC->TileWidth = 2;
							randoNPC->TileHeight = 2;
							randoNPC->HitHeight = 32;
							randoNPC->HitWidth = 32;
							randoNPC->HitXOffset = -8;
							randoNPC->DrawXOffset = -8;
							if (IsSideview())
							{
								randoNPC->HitYOffset = -16;
								randoNPC->DrawYOffset = -16;
							}
							else
							{
								randoNPC->HitYOffset = -8;
								randoNPC->DrawYOffset = -8;
							}
						}
					}

		// --- Ally NPCs fire lweapons (Good Octorok)
					if (randoNPC->Misc[MISC_NPCLWEAPON] > 0){
						if (randoNPC->Misc[MISC_NPCLWEAPONTIMER] > 0) randoNPC->Misc[MISC_NPCLWEAPONTIMER] --;
						else
						{
							lweapon NPCLWeap = CreateLWeaponAt(randoNPC->Misc[MISC_NPCLWEAPON],randoNPC->X,randoNPC->Y);
							NPCLWeap->UseSprite(randoNPC->Misc[MISC_NPCLWEAPONSPRITE]);
							NPCLWeap->Damage = randoNPC->WeaponDamage;
							NPCLWeap->Dir = randoNPC->Dir;
							NPCLWeap->Step = 255;
							randoNPC->Misc[MISC_NPCLWEAPONTIMER] = Rand(32,128);
						}
					}



		// --- NPCs' weapon type is switched to a Script weapon based on using special Item Drop Sets
		// Sorry for this workaround, but I wanted a handy way to set their weapons to EW_SCRIPT weapons from the editor.

					if (randoNPC->ItemSet == IS_BOLA)
					{
						if (randoNPC->Weapon != EW_BOLA) randoNPC->Weapon = EW_BOLA;
					}


					if (randoNPC->ItemSet == IS_STATIONARYBOMB)
					{
						if (randoNPC->Weapon != EW_STATIONARYBOMB) randoNPC->Weapon = EW_STATIONARYBOMB;
					}


					if (randoNPC->ItemSet == IS_MACE)
					{
						if (randoNPC->Weapon != EW_MACE) randoNPC->Weapon = EW_MACE;
					}



		// --- Tougher Monsters effect

					if (Link->Item[I_TOUGHMONSTERS])
					{	
						if (randoNPC->Misc[MISC_TOUGHENEMY] == 0)
						{
							randoNPC->HP = randoNPC->HP*2;
							randoNPC->Damage = randoNPC->Damage + 4;
							randoNPC->WeaponDamage = randoNPC->WeaponDamage + 2;	
							if (randoNPC->ID == NPCT_WALK && randoNPC->Step > 0) randoNPC->Step = randoNPC->Step + 20;					
							if (randoNPC->Type != NPCT_GUY && randoNPC->Type != NPCT_GANON){
								if (randoNPC->CSet == 8) randoNPC->CSet = 7;
								else if (randoNPC->CSet == 7) randoNPC->CSet = 5;
								else if (randoNPC->CSet == 9) randoNPC->CSet = 10;
								else if (randoNPC->CSet >= 12) randoNPC->CSet = 11;
							}
							randoNPC->Misc[MISC_TOUGHENEMY] = 1;
						}
					}


		// --- Leevers are killed by the shovel
					if (DigDelay > 0)
					{
						if (randoNPC->Type == NPCT_LEEVER)
						{
							if (LinkCollision(randoNPC)) randoNPC->HP = 0;

						}
					}





		// --- Enemies shoot eweapons that normally can't
		// Applies to Tektites, Leevers, Peahats, Rocks, Ghini, Keese, Traps, Wallmasters, Dodongos, Other, and Other(Floating)

					if (randoNPC->Weapon != 0)
					{
						if (randoNPC->Stun == 0)
						{
							if (randoNPC->HP > 0)
							{
								if (randoNPC->Misc[MISC_NPCSHOOT] == 0) randoNPC->Misc[MISC_NPCSHOOT] = Rand(96,160); 
								else randoNPC->Misc[MISC_NPCSHOOT] --;
								if (randoNPC->Misc[MISC_NPCSHOOT] == 1)
								{
									if (randoNPC->Type >= NPCT_TEKTITE && randoNPC->Type <= NPCT_WALLMASTER && randoNPC->Type != NPCT_ZORA || randoNPC->Type >= NPCT_OTHERFLOAT && randoNPC->Type <= NPCT_OTHER || randoNPC->Type == NPCT_DODONGO)
									{
										if (randoNPC->Attributes[10] == 0 && randoNPC->Attributes[11] == 0 || randoNPC->Type < NPCT_OTHERFLOAT || randoNPC->Type > NPCT_OTHER)
										{
											eweapon randoShoot = CreateEWeaponAt(randoNPC->Weapon, randoNPC->X + ((randoNPC->TileWidth-1)*8), randoNPC->Y + ((randoNPC->TileHeight-1)*8) );
											randoShoot->Dir = randoNPC->Dir;
											randoShoot->Damage = randoNPC->WeaponDamage;
											if (randoNPC-> Weapon == EW_MAGIC) Game->PlaySound(SFX_WAND);	
											else if (randoNPC-> Weapon == EW_FIRE || randoNPC-> Weapon == EW_FIRE2) Game->PlaySound(SFX_FIRE);	
											randoNPC->Misc[MISC_NPCSHOOT] = Rand(96,160);
										}
									}
								}
							}
						}
					}

		// --- Moving Gleeoks
					if (randoNPC->Type == NPCT_GLEEOK)
					{
						//Uses ->Attributes[9], which is listed as "Misc. Attr. 10" in the enemy editor

						if (randoNPC->Stun == 0 && randoNPC->CSet != 8 && randoNPC->HP > 0)
						{
							if (randoNPC->Attributes[NPCA_WALK_WALK_ATTRIB] == 1)
							{
								if (randoNPC->X > 32)
								{
									randoNPC->X --;
									randoNPC->Stun = 2;
								}
								else
								{ 
									randoNPC->Attributes[NPCA_WALK_WALK_ATTRIB] = 2;
									randoNPC->Stun = 16;
								}
							}
							if (randoNPC->Attributes[NPCA_WALK_WALK_ATTRIB] == 2)
							{
								if (randoNPC->X <208)
								{
									randoNPC->X ++;
									randoNPC->Stun = 2;
								}
								else
								{
									randoNPC->Attributes[NPCA_WALK_WALK_ATTRIB] = 1;
									randoNPC->Stun = 16;
								}
							}
						}
					}


		// --- end



				}
			}

// --------------------------------------- Chapter 17: Every-frame NPC checks / for loop of NPCs (end)







// --------------------------------------- Chapter 18: Every-frame LWeapon checks / for loop of Lweapons (start)
			for(ForTimer = Screen->NumLWeapons(); ForTimer > 0; ForTimer--)
			{
				randoLW = Screen->LoadLWeapon(ForTimer);
				if(!randoLW->isValid()) continue;
				{


		// --- LWeapons move on conveyor belts
					if (Screen->ComboT[ComboAt(randoLW->X+7,randoLW->Y+8)] == CT_CVUP && CanWalk(randoLW->X,randoLW->Y,DIR_UP,1,false)) randoLW->Y --;
					if (Screen->ComboT[ComboAt(randoLW->X+7,randoLW->Y+8)] == CT_CVDOWN && CanWalk(randoLW->X,randoLW->Y,DIR_DOWN,1,false)) randoLW->Y ++;
					if (Screen->ComboT[ComboAt(randoLW->X+7,randoLW->Y+8)] == CT_CVLEFT && CanWalk(randoLW->X,randoLW->Y,DIR_LEFT,1,false)) randoLW->X --;
					if (Screen->ComboT[ComboAt(randoLW->X+7,randoLW->Y+8)] == CT_CVRIGHT && CanWalk(randoLW->X,randoLW->Y,DIR_RIGHT,1,false)) randoLW->X ++;

		// --- LW_REFROCK doesn't damage Link
					if (randoLW->ID == LW_REFROCK)
					{
						if (randoLW->CollDetection == 0)
						{
							if (!LinkCollision(randoLW)) randoLW->CollDetection = 1;
						}
						else
						{
							if (LinkCollision(randoLW)) randoLW->CollDetection = 0;
						}
					}

		// --- LWeapon->Misc[] attribute for temporary no collision detection
					if (randoLW->CollDetection == 0)
					{
						if (randoLW->Misc[MISC_TEMPNOCOLLIDELW] > 0)
						{
							randoLW->Misc[MISC_TEMPNOCOLLIDELW] --;
							if (randoLW->Misc[MISC_TEMPNOCOLLIDELW] == 1)
							{
								randoLW->CollDetection = 1;
								randoLW->Misc[MISC_TEMPNOCOLLIDELW] = 0;
							}
						}

					}
		// --- LWeapon->Misc[] attribute for removal after timeout
					if (randoLW->Misc[MISC_LWTIMEOUT] > 0)
					{
						if (randoLW->Misc[MISC_LWTIMEOUT] > 1) randoLW->Misc[MISC_LWTIMEOUT] --;
						else Remove(randoLW);
					}

		// --- Item: Bola movement. See also item script "ItemCreatesLWeapon".

					if (randoLW->ID == LW_BOLA)
					{
						if (randoLW->Misc[MISC_BOLA]<48) randoLW->Misc[MISC_BOLA]++;
						if (randoLW->Misc[MISC_BOLA] < 16)
						{
							if (randoLW->Y > 8) randoLW->Y = randoLW->Y - 2; 
							else randoLW->Z = randoLW->Z + 2;
						}
						if (randoLW->Misc[MISC_BOLA] > 15 && randoLW->Misc[MISC_BOLA] < 32)
						{
							if (randoLW->Y > 8) randoLW->Y --;
							else randoLW->Z ++;
						}
						if (randoLW->Misc[MISC_BOLA] > 36 && randoLW->Z > 0) randoLW->Z = randoLW->Z - 2;
						if (randoLW->Misc[MISC_BOLA] > 36 && randoLW->Misc[MISC_BOLA] < 48) randoLW->Y = randoLW->Y+2;
						if (randoLW->Misc[MISC_BOLA] > 47) randoLW->Y = randoLW->Y+3;
						if (randoLW->Dir == DIR_RIGHT) randoLW->X ++;
						if (randoLW->Dir == DIR_LEFT) randoLW->X --;
						if (randoLW->Y < 160) randoLW->DeadState = WDS_ALIVE;
					}
		// --- End

				}
			}

// --------------------------------------- Chapter 18: Every-frame LWeapon checks / for loop of Lweapons (end)





// --------------------------------------- Chapter 19: Item: Armos (start)
// See also item script "ItemCreatesLWeapon", and the "Can be pushed by Armos LWeapons" section of Somaria Pushblocks.


			if (ArmosFriend->isValid())
			{
		// --- Armos activation
				if (ArmosStatus[FRIEND_SNOOZE] == 0)
				{
					if (ArmosStatus[FRIEND_TIMER] == 0) ArmosStatus[FRIEND_TIMER] = 62;
					else if (ArmosStatus[FRIEND_TIMER] > 2) ArmosStatus[FRIEND_TIMER] --;
					if (ArmosStatus[FRIEND_TIMER] == 2)
					{
						ArmosStatus[FRIEND_STARTX] = ArmosFriend->X;
						ArmosStatus[FRIEND_STARTY] = ArmosFriend->Y;
						ArmosStatus[FRIEND_LINK_STARTX] = Link->X;
						ArmosStatus[FRIEND_LINK_STARTY] = Link->Y;
						ArmosStatus[FRIEND_TIMER] = 1;
						ArmosFriend->UseSprite(SP_ARMOS);
					}

		// --- Armos moves
					else if (ArmosStatus[FRIEND_TIMER] == 1)
					{
						ArmosFriend->Dir = Link->Dir;
						ArmosStatus[FRIEND_GOX] = ArmosStatus[FRIEND_STARTX] - (ArmosStatus[FRIEND_LINK_STARTX] - Link->X);
						ArmosStatus[FRIEND_GOY] = ArmosStatus[FRIEND_STARTY] - (ArmosStatus[FRIEND_LINK_STARTY] - Link->Y);

						if (ArmosFriend->Y > ArmosStatus[FRIEND_GOY] && CanWalk(ArmosFriend->X,ArmosFriend->Y,DIR_UP,1,false) && ArmosFriend->Y > 8)
						{
							// Doesn't go up in sideview unless on a ladder
							if (!IsSideview() || Screen->ComboT[ComboAt(ArmosFriend->X+7,ArmosFriend->Y+8)] == CT_SIDECLIMB || Screen->ComboT[ComboAt(ArmosFriend->X+7,ArmosFriend->Y+16)] == CT_SIDECLIMB) ArmosFriend->Y --;
						}
						if (ArmosFriend->Y < ArmosStatus[FRIEND_GOY] && CanWalk(ArmosFriend->X,ArmosFriend->Y,DIR_DOWN,1,false) && ArmosFriend->Y < 152) ArmosFriend->Y ++;
						if (ArmosFriend->X > ArmosStatus[FRIEND_GOX] && CanWalk(ArmosFriend->X,ArmosFriend->Y,DIR_LEFT,1,false) && ArmosFriend->X > 8) ArmosFriend->X --;
						if (ArmosFriend->X < ArmosStatus[FRIEND_GOX] && CanWalk(ArmosFriend->X,ArmosFriend->Y,DIR_RIGHT,1,false) && ArmosFriend->X < 232) ArmosFriend->X ++;

		// --- Armos deactivation
						if (Link->PressB && GetEquipmentB() == I_ARMOS || Link->PressA && GetEquipmentA() == I_ARMOS)
						{
							ArmosStatus[FRIEND_TIMER] = 0;
							ArmosStatus[FRIEND_SNOOZE] = 1;
							ArmosFriend->UseSprite(SP_ARMOSSLEEP);
							ArmosFriend->CSet = Screen->ComboC[ComboAt(ArmosFriend->X+7,ArmosFriend->Y+8)];
							Game->PlaySound(SFX_PLACE);
						}
					}

		// --- Armos falls in sideview...
					if (IsSideview())
					{
						if (CanWalk(ArmosFriend->X,ArmosFriend->Y,DIR_DOWN,1,false))
						{
		// ...unless the Armos is on a ladder
							if (Screen->ComboT[ComboAt(ArmosFriend->X+7,ArmosFriend->Y+8)] != CT_SIDECLIMB && Screen->ComboT[ComboAt(ArmosFriend->X+7,ArmosFriend->Y+17)] != CT_SIDECLIMB)
							{
								ArmosFriend->Y ++;
								if (Screen->ComboS[ComboAt(ArmosFriend->X+7,ArmosFriend->Y+18)] == 0) ArmosFriend->Y ++;
							}
						}
					}
				}

		// --- Armos reactivation
				else if (Link->PressB && GetEquipmentB() == I_ARMOS || Link->PressA && GetEquipmentA() == I_ARMOS)
				{
					ArmosFriend->UseSprite(SP_ARMOSWAKE);
					ArmosStatus[FRIEND_TIMER] = 24;
					ArmosStatus[FRIEND_SNOOZE] = 0;
					Game->PlaySound(SFX_WAND);
						
				}
		// --- Armos HP
				if (ArmosFriend->DeadState != WDS_ALIVE)
				{
					{
						if (ArmosStatus[FRIEND_HP] > 0)
						{
							ArmosFriend->DeadState = WDS_ALIVE;
							ArmosFriend->CollDetection = 0;
							ArmosFriend->Misc[MISC_TEMPNOCOLLIDELW] = 60;
							ArmosStatus[FRIEND_IFRAMES] = 60;
							Game->PlaySound(SFX_MSG);
							ArmosStatus[FRIEND_HP] --;
						}
						else if (NumLWeaponsOf(LW_SPARKLE) == 0)
						{
							lweapon ArmosBye = CreateLWeaponAt(LW_SPARKLE,ArmosFriend->X,ArmosFriend->Y);
							ArmosBye->UseSprite(SP_MISC_DEATH);
						}
					}
				}
				if (ArmosStatus[FRIEND_IFRAMES] > 0)
				{
					ArmosStatus[FRIEND_IFRAMES] --;
					Screen->FastTile(3,
						ArmosFriend->X,
						ArmosFriend->Y + ArmosFriend->DrawYOffset, 
						ArmosFriend->Tile,
						Choose(7,8),128);
				}
			}

		// --- Look for a valid Armos
			else if (NumLWeaponsOf(LW_ARMOS) > 0) ArmosFriend = LoadLWeaponOf(LW_ARMOS);


			if (ArmosStatus[FRIEND_TIMER] > 0 || ArmosStatus[FRIEND_SNOOZE] > 0)
			{
				if (NumLWeaponsOf(LW_ARMOS) == 0)
				{
					ArmosStatus[FRIEND_TIMER] = 0;
					ArmosStatus[FRIEND_HP] = 2;
					ArmosStatus[FRIEND_SNOOZE] = 0;
				}
			}
// --------------------------------------- Chapter 19: Item: Armos (end)












// --------------------------------------- Chapter 20: Item: Pegasus Boots (start)

	// ----- Super Pegasus Boots direction-changing
			if (Link->Item[I_SUPERPEGASUS] && PegasusTimer > 0 && PegasusTimer < 100)
			{
				if (Link->PressUp && Link->Dir != DIR_DOWN)
				{
					Link->Dir = DIR_UP;
					PegasusDir = DIR_UP;
				}
				if (Link->PressDown && Link->Dir != DIR_UP)
				{
					Link->Dir = DIR_DOWN;
					PegasusDir = DIR_DOWN;
				}
				if (Link->PressLeft && Link->Dir != DIR_RIGHT)
				{
					Link->Dir = DIR_LEFT;
					PegasusDir = DIR_LEFT;
				}
				if (Link->PressRight && Link->Dir != DIR_LEFT)
				{
					Link->Dir = DIR_RIGHT;
					PegasusDir = DIR_RIGHT;
				}
			}


	// ----- Can't dash on CF_PEGASTOP flag / getting hurt stops dash
			if (Screen->ComboF[ComboAt(Link->X+7,Link->Y+8)] == CF_PEGASTOP || Link->Action == LA_GOTHURTLAND) PegasusTimer = 0;


	// ----- Pegasus Boot delay before dashing
			if (Link->InputB && GetEquipmentB() == I_PEGASUS || Link->InputA && GetEquipmentA() == I_PEGASUS || Link->InputB && GetEquipmentB() == I_SUPERPEGASUS || Link->InputA && GetEquipmentA() == I_SUPERPEGASUS)
			{
				if (PegasusTimer < 40 && Screen->ComboS[ComboAt(Link->X+7,Link->Y+8)] == 0 && DoDraw)
				{
					PegasusTimer ++;				
					if (!Link->Item[I_SUPERPEGASUS]) NoAction();					
					if (!(PegasusTimer%6))
					{
						Game->PlaySound(SFX_PEGASUS);
						lweapon BootDust = CreateLWeaponAt(LW_SPARKLE,Choose(Link->X-4,Link->X+4),Link->Y+12);
						BootDust->UseSprite(SP_PEGASUSDUST);
					}
				}
				if (PegasusTimer == 40)
				{
					PegasusDir = Link->Dir;
					PegasusTimer = 48;
				}
				if (!Link->Item[I_SUPERPEGASUS])
				{
					if (Link->PressUp && Link->Dir != DIR_UP || Link->PressDown && Link->Dir != DIR_DOWN || Link->PressLeft && Link->Dir != DIR_LEFT || Link->PressRight && Link->Dir != DIR_RIGHT) PegasusTimer = 0;
				}
			}
			else if (PegasusTimer < 40 && PegasusTimer > 0) PegasusTimer = 0;


	// ----- Pegasus Boots dashing
			if (PegasusTimer >= 48 && PegasusTimer != 100)
			{
				if (!(PegasusTimer%6)) Game->PlaySound(SFX_PEGASUS);
				if (!(PegasusTimer%4))
				{
					if (Link->Item[I_SUPERPEGASUS])
					{
						lweapon BootDust = CreateLWeaponAt(LW_LANMOLA,Link->X,Link->Y+4);
						BootDust->Damage = 4;
						BootDust->UseSprite(SP_PEGASUSDUST2);
						BootDust->Misc[MISC_LWTIMEOUT] = 36;
					}
					else
					{
						lweapon BootDust = CreateLWeaponAt(LW_SPARKLE,Link->X,Link->Y+12);
						BootDust->UseSprite(SP_PEGASUSDUST);
					}
				}
				if (PegasusTimer == 54) PegasusTimer = 48;
				else PegasusTimer ++;


	// ----- Dash up
				if (PegasusDir == DIR_UP)
				{
					if (!IsSideview())
					{
						//if (Screen->ComboS[ComboAt(Link->X+7,Link->Y-1)] == 0 && Screen->ComboS[ComboAt(Link->X+8,Link->Y-1)] == 0)
						if (CanWalk(Link->X,Link->Y,DIR_UP,1,false) || Link->Y < 2)
						{
							if (Screen->ComboT[ComboAt(Link->X+7,Link->Y+8)] != CT_SLOWWALK) Link->Y --;
						}
						else{
							if (Screen->ComboT[ComboAt(Link->X+7,Link->Y-1)] == CT_PEGASUSOBSTACLE || Screen->ComboT[ComboAt(Link->X+8,Link->Y-1)] == CT_PEGASUSOBSTACLE)
							{
								if (Screen->ComboT[ComboAt(Link->X+7,Link->Y-1)] == CT_PEGASUSOBSTACLE) Screen->ComboD[ComboAt(Link->X+7,Link->Y-1)] = Screen->UnderCombo;
								if (Screen->ComboT[ComboAt(Link->X+8,Link->Y-1)] == CT_PEGASUSOBSTACLE) Screen->ComboD[ComboAt(Link->X+8,Link->Y-1)] = Screen->UnderCombo;
								if (Screen->ComboF[ComboAt(Link->X+8,Link->Y-1)] == CF_PEGASUSSECRET)
								{
									Screen->ComboD[ComboAt(Link->X+8,Link->Y-1)] = Screen->RoomData;
									Game->PlaySound(27);
									PegasusBonk();
									PegasusTimer = 100;
								}
								if (Screen->ComboF[ComboAt(Link->X+7,Link->Y-1)] == CF_PEGASUSSECRET)
								{
									Screen->ComboD[ComboAt(Link->X+7,Link->Y-1)] = Screen->RoomData;
									Game->PlaySound(27);
									PegasusBonk();
									PegasusTimer = 100;
								}
								PegasusShrapnel();								
							}
							else{
								PegasusBonk();
								PegasusTimer = 100;
							}
						}
					}
					Link->InputUp = true;
					if (Link->PressDown || !Link->Item[I_SUPERPEGASUS] && Link->PressLeft || !Link->Item[I_SUPERPEGASUS] && Link->PressRight) PegasusTimer = 0;
				}




	// ----- Dash down
				if (PegasusDir == DIR_DOWN)
				{
					if (CanWalk(Link->X,Link->Y,DIR_DOWN,1,false) || Link->Y > 158)
					//if (Screen->ComboS[ComboAt(Link->X+7,Link->Y+17)] == 0 && Screen->ComboS[ComboAt(Link->X+8,Link->Y+17)] == 0)
					{
						if (Screen->ComboT[ComboAt(Link->X+7,Link->Y+8)] != CT_SLOWWALK) Link->Y ++;
					}
					else{
						if (Screen->ComboT[ComboAt(Link->X+7,Link->Y+17)] == CT_PEGASUSOBSTACLE || Screen->ComboT[ComboAt(Link->X+8,Link->Y+17)] == CT_PEGASUSOBSTACLE)
						{
							if (Screen->ComboT[ComboAt(Link->X+7,Link->Y+17)] == CT_PEGASUSOBSTACLE) Screen->ComboD[ComboAt(Link->X+7,Link->Y+17)] = Screen->UnderCombo;
							if (Screen->ComboT[ComboAt(Link->X+8,Link->Y+17)] == CT_PEGASUSOBSTACLE) Screen->ComboD[ComboAt(Link->X+8,Link->Y+17)] = Screen->UnderCombo;
							if (Screen->ComboF[ComboAt(Link->X+7,Link->Y+17)] == CF_PEGASUSSECRET)
							{
								Screen->ComboD[ComboAt(Link->X+7,Link->Y+17)] = Screen->RoomData;
								Game->PlaySound(27);
								PegasusBonk();
								PegasusTimer = 100;
							}
							if (Screen->ComboF[ComboAt(Link->X+8,Link->Y+17)] == CF_PEGASUSSECRET)
							{
								Screen->ComboD[ComboAt(Link->X+8,Link->Y+17)] = Screen->RoomData;
								Game->PlaySound(27);
								PegasusBonk();
								PegasusTimer = 100;
							}
							PegasusShrapnel();
						}
						else{
							PegasusBonk();
							PegasusTimer = 100;
						}
					}
					Link->InputDown = true;
					if (Link->PressUp || !Link->Item[I_SUPERPEGASUS] && Link->PressLeft || !Link->Item[I_SUPERPEGASUS] && Link->PressRight) PegasusTimer = 0;
				}



	// ----- Dash left
				if (PegasusDir == DIR_LEFT)
				{
					//if (Screen->ComboS[ComboAt(Link->X-1,Link->Y+8)] == 0 && Screen->ComboS[ComboAt(Link->X-1, Link->Y+12)] == 0)
					if (CanWalk(Link->X,Link->Y,DIR_LEFT,1,false) || Link->X < 2)
					{
						if (Screen->ComboT[ComboAt(Link->X+7,Link->Y+8)] != CT_SLOWWALK) Link->X --;
					}
					else{
						if (Screen->ComboT[ComboAt(Link->X-1,Link->Y+8)] == CT_PEGASUSOBSTACLE || Screen->ComboT[ComboAt(Link->X-1, Link->Y+12)] == CT_PEGASUSOBSTACLE)
						{
							if (Screen->ComboT[ComboAt(Link->X-1,Link->Y+8)] == CT_PEGASUSOBSTACLE) Screen->ComboD[ComboAt(Link->X-1,Link->Y+8)] = Screen->UnderCombo;
							if (Screen->ComboT[ComboAt(Link->X-1, Link->Y+12)] == CT_PEGASUSOBSTACLE) Screen->ComboD[ComboAt(Link->X-1, Link->Y+12)] = Screen->UnderCombo;


							if (Screen->ComboF[ComboAt(Link->X-1,Link->Y+8)] == CF_PEGASUSSECRET)
							{
								Screen->ComboD[ComboAt(Link->X-1,Link->Y+8)] = Screen->RoomData;
								Game->PlaySound(27);
								PegasusBonk();
								PegasusTimer = 100;
							}
							if (Screen->ComboF[ComboAt(Link->X-1, Link->Y+12)] == CF_PEGASUSSECRET)
							{
								Screen->ComboD[ComboAt(Link->X-1, Link->Y+12)] = Screen->RoomData;
								Game->PlaySound(27);
								PegasusBonk();
								PegasusTimer = 100;
							}
							PegasusShrapnel();
						}
						else
						{
							PegasusBonk();
							PegasusTimer = 100;
						}
					}
					Link->InputLeft = true;
					if (Link->PressRight || !Link->Item[I_SUPERPEGASUS] && Link->PressUp || !Link->Item[I_SUPERPEGASUS] && Link->PressDown) PegasusTimer = 0;
				}




	// ----- Dash right
				if (PegasusDir == DIR_RIGHT)
				{
					//if (Screen->ComboS[ComboAt(Link->X+17,Link->Y+8)] == 0 && Screen->ComboS[ComboAt(Link->X+17, Link->Y+12)] == 0)
					if (CanWalk(Link->X,Link->Y,DIR_RIGHT,1,false) || Link->X > 238)
					{
						if (Screen->ComboT[ComboAt(Link->X+7,Link->Y+8)] != CT_SLOWWALK) Link->X ++;
					}
					else{
						if (Screen->ComboT[ComboAt(Link->X+17,Link->Y+8)] == CT_PEGASUSOBSTACLE || Screen->ComboT[ComboAt(Link->X+17, Link->Y+12)] == CT_PEGASUSOBSTACLE)
						{
							if (Screen->ComboT[ComboAt(Link->X+17,Link->Y+8)] == CT_PEGASUSOBSTACLE) Screen->ComboD[ComboAt(Link->X+17,Link->Y+8)] = Screen->UnderCombo;
							if (Screen->ComboT[ComboAt(Link->X+17, Link->Y+12)] == CT_PEGASUSOBSTACLE) Screen->ComboD[ComboAt(Link->X+17, Link->Y+12)] = Screen->UnderCombo;

							if (Screen->ComboF[ComboAt(Link->X+17,Link->Y+8)] == CF_PEGASUSSECRET)
							{ 
								Screen->ComboD[ComboAt(Link->X+17,Link->Y+8)] = Screen->RoomData;
								Game->PlaySound(27);
								PegasusBonk();
								PegasusTimer = 100;
							}
							if (Screen->ComboF[ComboAt(Link->X+17, Link->Y+12)] == CF_PEGASUSSECRET)
							{ 
								Screen->ComboD[ComboAt(Link->X+17, Link->Y+12)] = Screen->RoomData;
								Game->PlaySound(27);
								PegasusBonk();
								PegasusTimer = 100;
							}
							PegasusShrapnel();
						}
						else
						{
							PegasusBonk();
							PegasusTimer = 100;
						}
					}
					Link->InputRight = true;
					if (Link->PressLeft || !Link->Item[I_SUPERPEGASUS] && Link->PressUp || !Link->Item[I_SUPERPEGASUS] && Link->PressDown) PegasusTimer = 0;
				}
			}


	// ----- Pegasus bonk moves Link (Zelda)
			if (PegasusTimer == 100)
			{
				if (Link->Z > 0)
				{
					NoAction();
					if(Link->Dir == DIR_UP) PushLink(DIR_DOWN);
					if(Link->Dir == DIR_DOWN) PushLink(DIR_UP);
					if(Link->Dir == DIR_LEFT) PushLink(DIR_RIGHT);
					if(Link->Dir == DIR_RIGHT) PushLink(DIR_LEFT);
				}
				else PegasusTimer = 0;
			}


			if (PegasusDir != Link->Dir) PegasusDir = Link->Dir;




// --------------------------------------- Chapter 20: Item: Pegasus Boots (end)








// --------------------------------------- Chapter 21: Item: Cane of Somaria and Item: Handy Glove (start)
// Both in one section because they share the LW_SWORD weapon.
// See also: Chapter 22: Somaria pushblocks 

			if (Link->Item[I_HANDYGLOVE])
			{
				if (NumLWeaponsOf(LW_ARROW) > 0)
				{
					if (randoLW->ID != LW_ARROW) randoLW = LoadLWeaponOf(LW_ARROW);
					else if (Screen->ComboT[ComboAt(randoLW->X+7,randoLW->Y+8)] == CT_HANDYBLOCK)
					{
						Game->PlaySound(SFX_SHATTERING);
						lweapon BlockPoof = CreateLWeaponAt(LW_SPARKLE,ComboX(ComboAt(randoLW->X+7,randoLW->Y+8)),ComboY(ComboAt(randoLW->X+7,randoLW->Y+8)));
						BlockPoof->UseSprite(SP_SPAWN);
						Screen->ComboD[ComboAt(randoLW->X+7,randoLW->Y+8)] = Screen->UnderCombo;
						randoLW->DeadState = WDS_ARROW;
					}
				}
			}


			if (NumLWeaponsOf(LW_SWORD) > 0)
			{
				if (randoLW->ID != LW_SWORD) randoLW = LoadLWeaponOf(LW_SWORD);
	
				if (randoLW->ID == LW_SWORD)
				{
					if (Link->Item[I_HANDYGLOVE])
					{
					if (Screen->ComboT[ComboAt(randoLW->X+7,randoLW->Y+8)] == CT_HANDYBLOCK)
						{
							lweapon BlockPoof = CreateLWeaponAt(LW_SPARKLE,ComboX(ComboAt(randoLW->X+7,randoLW->Y+8)),ComboY(ComboAt(randoLW->X+7,randoLW->Y+8)));
							BlockPoof->UseSprite(SP_SPAWN);
							Game->PlaySound(SFX_SHATTERING);
							Screen->ComboD[ComboAt(randoLW->X+7,randoLW->Y+8)] = Screen->UnderCombo;
						}
					}
				}
			}

// --------------------------------------- Chapter 21: Item: Cane of Somaria and Item: Handy Glove (end)






// --------------------------------------- Chapter 22: Somaria pushblocks (start)
// Note: Somaia Blocks are created/destroyed by item script "SomariaCane".

			if (NumLWeaponsOf(LW_SOMARIA) > 0)
			{
				if(SomariaBlock->isValid())
				{

			// Standing on top of the block
					if (IsSideview())
					{
						if (CanWalk(SomariaBlock->X,SomariaBlock->Y,DIR_DOWN,1,false) || SomariaBlock->Y > 158) SomariaBlock->Y = SomariaBlock->Y + 2;
						if (Link->Y < SomariaBlock->Y+8)
						{
							if (LinkCollision(SomariaBlock)) Link->Jump = 0;
						}
					}

			// Pushing the block
					if (Link->Z == 0)
					{
						if (LinkCollision(SomariaBlock))
						{

							if (Link->Y > SomariaBlock->Y+7 && Link->X > SomariaBlock->X -12 && Link->X < SomariaBlock->X + 12)
							{
								SomariaBlock->Y --;
								SomariaBlock->Dir = DIR_UP;
								if (PegasusTimer > 47 && PegasusTimer < 55) SomariaBlock->Step = 255;
								PushLink(DIR_DOWN);
							}
							else if (Link->Y < SomariaBlock->Y+8 && Link->X > SomariaBlock->X -12 && Link->X < SomariaBlock->X + 12)
							{
								if (!IsSideview() || Link->InputDown || Screen->ComboS[ComboAt(SomariaBlock->X+7,SomariaBlock->Y+17)] == 0)
								{
									SomariaBlock->Y ++;
									SomariaBlock->Dir = DIR_DOWN;
									if (PegasusTimer > 47 && PegasusTimer < 55) SomariaBlock->Step = 25;
									PushLink(DIR_UP);
								}
							}
							else if (Link->X > SomariaBlock->X+7 && Link->Y > SomariaBlock->Y -14 && Link->Y < SomariaBlock->Y + 12)
							{
								if (!IsSideview() || Link->Y > SomariaBlock->Y-12)
								{
									SomariaBlock->X --;
									SomariaBlock->Dir = DIR_LEFT;
									if (PegasusTimer > 47 && PegasusTimer < 55) SomariaBlock->Step = 255;
									PushLink(DIR_RIGHT);
								}
							}
							else if (Link->X < SomariaBlock->X+8 && Link->Y > SomariaBlock->Y -14 && Link->Y < SomariaBlock->Y + 12)
							{
								if (!IsSideview() || Link->Y > SomariaBlock->Y-12)
								{
									SomariaBlock->X ++;
									SomariaBlock->Dir = DIR_RIGHT;
									if (PegasusTimer > 47 && PegasusTimer < 55) SomariaBlock->Step = 255;
									PushLink(DIR_LEFT);
								}
							}
						}
					}
			// Can be pushed by Armos LWeapons
					if (NumLWeaponsOf(LW_ARMOS) > 0)
					{
						if (randoLW->ID != LW_ARMOS) randoLW = LoadLWeaponOf(LW_ARMOS);
						{
							if (randoLW->isValid())
							{
								if (Collision (randoLW,SomariaBlock))
								{
									if (randoLW->Y > SomariaBlock->Y - 8 && randoLW->Y < SomariaBlock->Y + 12)
									{
										if (randoLW->X < SomariaBlock->X+4) SomariaBlock->X ++;
										else if (randoLW->X > SomariaBlock->X+12) SomariaBlock->X --;
									}
									if (randoLW->X > SomariaBlock->X - 8 && randoLW->X < SomariaBlock->X + 12)
									{
										if (randoLW->Y < SomariaBlock->Y+4) SomariaBlock->Y ++;
										else if (randoLW->Y > SomariaBlock->Y+12) SomariaBlock->Y --;
									}
								}
							}
						}

					}


				}
				else SomariaBlock = LoadLWeaponOf(LW_SOMARIA);
			}
// --------------------------------------- Chapter 22: Somaria pushblocks (end)







// --------------------------------------- Chapter 23: Item: Shovel (start)
//
// Maybe this should be redone to launch an FFC script or use functions or something? But it's working as-is.



			if (DigDelay == 0 && Link->Action < 3 && DoDraw)
			{
				if (GetEquipmentB() == I_SHOVEL && Link->PressB || GetEquipmentA() == I_SHOVEL && Link->PressA) DigDelay = 24;
			}

			if (DigDelay > 0)
			{
				//NoAction();
				DigDelay --;
			}

			if (DigDelay > 12)
			{
				Link->Action = LA_NONE;
				Link->Action = LA_ATTACKING;
				if (Link->Dir == DIR_RIGHT) Screen->FastTile(1,Link->X+8,Link->Y+2,SHOVEL_TILE+2,6,128);
				if (Link->Dir == DIR_LEFT) Screen->FastTile(1,Link->X-8,Link->Y+2,SHOVEL_TILE,6,128);
				if (Link->Dir == DIR_UP) Screen->FastTile(1,Link->X+4,Link->Y-4,SHOVEL_TILE+2,6,128);
				if (Link->Dir == DIR_DOWN) Screen->FastTile(3,Link->X,Link->Y+4,SHOVEL_TILE,6,128);
			}
			if (DigDelay > 0 && DigDelay < 13){
				if (Link->Dir == DIR_RIGHT) Screen->FastTile(3,Link->X-8,Link->Y-4,SHOVEL_TILE+3,6,128);
				if (Link->Dir == DIR_LEFT) Screen->FastTile(3,Link->X+8,Link->Y-4,SHOVEL_TILE+1,6,128);
				if (Link->Dir == DIR_UP) Screen->FastTile(3,Link->X-8,Link->Y,SHOVEL_TILE+3,6,128);
				if (Link->Dir == DIR_DOWN) Screen->FastTile(3,Link->X+8,Link->Y-2,SHOVEL_TILE+1,6,128);
			}



			if (DigDelay == 1)
				{
	// --- Facing Up
				if (Link->Dir == DIR_UP){
					// --- Diggable dirt:
					if (Screen->ComboT[ComboAt(Link->X+7,Link->Y-1)] == CT_DIGDIRT)
					{
						DirtThrow = CreateLWeaponAt(LW_SPARKLE,Link->X,Link->Y-12);
						DirtThrow->X = ComboX(ComboAt(Link->X+7,Link->Y-1));
						DirtThrow->UseSprite(SP_SHOVELDIRT);
						Game->PlaySound(SFX_SHOVEL);

						// --- Dig hidden items:
						if (Screen->ComboF[ComboAt(Link->X+7,Link->Y-1)] == CF_SHOVELITEM && !Screen->State[ST_SPECIALITEM]){
							item DugTreasure = CreateItemAt(Screen->RoomData,DirtThrow->X,DirtThrow->Y);
							DugTreasure->Pickup = IP_ST_SPECIALITEM + IP_HOLDUP;
							DugTreasure->Z = 16;
							DugTreasure->Jump = 1.5;
						}

						// --- Dig hidden combos:
						if (Screen->ComboF[ComboAt(Link->X+7,Link->Y-1)] == CF_SHOVELSECRET){
							Game->PlaySound(27);
							Screen->ComboD[ComboAt(Link->X+7,Link->Y-1)] = Screen->RoomData;
						}

						// --- Dig normal dirt:
						else
						{
							if (Screen->ComboS[ComboAt(Link->X+7,Link->Y-1)] != 0) Screen->ComboD[ComboAt(Link->X+7,Link->Y-1)] ++;
							else
							{
								DirtThrow->Misc[MISC_SHOVELFIND] = Rand(16);
								if (!IsSideview()) Screen->ComboD[ComboAt(Link->X+7,Link->Y-1)] = SHOVEL_POTHOLE;
								else Screen->ComboD[ComboAt(Link->X+7,Link->Y-1)] = Screen->UnderCombo;

								// --- Magical Bean Leevers
								if (Link->Item[I_MAGICBEAN])
								{
									if (NumLWeaponsOf(LW_LEEVER) < 8)
									{
										randoLW = CreateLWeaponAt(LW_LEEVER,ComboX(ComboAt(Link->X+7,Link->Y-1)),ComboY(ComboAt(Link->X+7,Link->Y-1)));
										randoLW->UseSprite(SP_LEEVER);
										randoLW->CSet = Screen->ComboC[ComboAt(Link->X+7,Link->Y-1)];
										randoLW->Damage = 4;	
										randoLW = CreateLWeaponAt(LW_WHISTLE,0,0);
									}
								}	
							}
						}
					}

					// --- Can't dig:
					else Game->PlaySound(SFX_CLINK);
				}

	// --- Facing Down
				if (Link->Dir == DIR_DOWN){
					if (Screen->ComboT[ComboAt(Link->X+7,Link->Y+17)] == CT_DIGDIRT)
					{
						DirtThrow = CreateLWeaponAt(LW_SPARKLE,Link->X,Link->Y+16);
						DirtThrow->X = ComboX(ComboAt(Link->X+7,Link->Y+17));
						DirtThrow->UseSprite(SP_SHOVELDIRT);
						Game->PlaySound(SFX_SHOVEL);
						// --- Dig hidden items:
						if (Screen->ComboF[ComboAt(Link->X+7,Link->Y+17)] == CF_SHOVELITEM && !Screen->State[ST_SPECIALITEM]){
							item DugTreasure = CreateItemAt(Screen->RoomData,DirtThrow->X,DirtThrow->Y);
							DugTreasure->Pickup = IP_ST_SPECIALITEM + IP_HOLDUP;
							DugTreasure->Z = 16;
							DugTreasure->Jump = 1.5;
						}

						// --- Dig hidden combos:
						if (Screen->ComboF[ComboAt(Link->X+7,Link->Y+17)] == CF_SHOVELSECRET){
							Game->PlaySound(27);
							Screen->ComboD[ComboAt(Link->X+7,Link->Y+17)] = Screen->RoomData;
						}

						// --- Dig normal dirt:
						else
						{
							if (Screen->ComboS[ComboAt(Link->X+7,Link->Y+17)] != 0) Screen->ComboD[ComboAt(Link->X+7,Link->Y+17)] ++;
							else
							{
								DirtThrow->Misc[MISC_SHOVELFIND] = Rand(16);
								if (!IsSideview()) Screen->ComboD[ComboAt(Link->X+7,Link->Y+17)] = SHOVEL_POTHOLE;
								else Screen->ComboD[ComboAt(Link->X+7,Link->Y+17)] = Screen->UnderCombo;

								// --- Magical Bean Leevers
								if (Link->Item[I_MAGICBEAN])
								{
									if (NumLWeaponsOf(LW_LEEVER) < 8)
									{
										randoLW = CreateLWeaponAt(LW_LEEVER,ComboX(ComboAt(Link->X+7,Link->Y+17)),ComboY(ComboAt(Link->X+7,Link->Y+17)));
										randoLW->UseSprite(SP_LEEVER);
										randoLW->CSet = Screen->ComboC[ComboAt(Link->X+7,Link->Y+17)];
										randoLW->Damage = 4;	
										randoLW = CreateLWeaponAt(LW_WHISTLE,0,0);
									}
								}
							}
						}
					}

					// --- Can't dig:
					else Game->PlaySound(SFX_CLINK);
				}

	// --- Facing Left
				if (Link->Dir == DIR_LEFT){
					if (Screen->ComboT[ComboAt(Link->X-1,Link->Y+8)] == CT_DIGDIRT)
					{
						DirtThrow = CreateLWeaponAt(LW_SPARKLE,Link->X-16,Link->Y);
						DirtThrow->Y = ComboY(ComboAt(Link->X-1,Link->Y+8));
						DirtThrow->UseSprite(SP_SHOVELDIRT);
						Game->PlaySound(SFX_SHOVEL);

						// --- Dig hidden items:
						if (Screen->ComboF[ComboAt(Link->X-1,Link->Y+8)] == CF_SHOVELITEM && !Screen->State[ST_SPECIALITEM]){
							item DugTreasure = CreateItemAt(Screen->RoomData,DirtThrow->X,DirtThrow->Y);
							DugTreasure->Pickup = IP_ST_SPECIALITEM + IP_HOLDUP;
							DugTreasure->Z = 16;
							DugTreasure->Jump = 1.5;
						}

						// --- Dig hidden combos:
						if (Screen->ComboF[ComboAt(Link->X-1,Link->Y+8)] == CF_SHOVELSECRET){
							Game->PlaySound(27);
							Screen->ComboD[ComboAt(Link->X-1,Link->Y+8)] = Screen->RoomData;
						}

						// --- Dig normal dirt:
						else
						{
							if (Screen->ComboS[ComboAt(Link->X-1,Link->Y+8)] != 0) Screen->ComboD[ComboAt(Link->X-1,Link->Y+8)] ++;
							else
							{
								DirtThrow->Misc[MISC_SHOVELFIND] = Rand(16);
								if (!IsSideview()) Screen->ComboD[ComboAt(Link->X-1,Link->Y+8)] = SHOVEL_POTHOLE;
								else Screen->ComboD[ComboAt(Link->X-1,Link->Y+8)] = Screen->UnderCombo;

								// --- Magical Bean Leevers
								if (Link->Item[I_MAGICBEAN])
								{
									if (NumLWeaponsOf(LW_LEEVER) < 8)
									{
										randoLW = CreateLWeaponAt(LW_LEEVER,ComboX(ComboAt(Link->X-1,Link->Y+8)),ComboY(ComboAt(Link->X-1,Link->Y+8)));
										randoLW->UseSprite(SP_LEEVER);
										randoLW->CSet = Screen->ComboC[ComboAt(Link->X-1,Link->Y+8)];
										randoLW->Damage = 4;
										randoLW = CreateLWeaponAt(LW_WHISTLE,0,0);
									}
								}
							}
						}
					}

					// --- Can't dig:
					else Game->PlaySound(SFX_CLINK);
				}
	// --- Facing Right
				if (Link->Dir == DIR_RIGHT){
					if (Screen->ComboT[ComboAt(Link->X+17,Link->Y+8)] == CT_DIGDIRT)
					{
						DirtThrow = CreateLWeaponAt(LW_SPARKLE,Link->X+16,Link->Y);
						DirtThrow->Y = ComboY(ComboAt(Link->X+17,Link->Y+8));
						DirtThrow->UseSprite(SP_SHOVELDIRT);
						Game->PlaySound(SFX_SHOVEL);

						// --- Dig hidden items:
						if (Screen->ComboF[ComboAt(Link->X+17,Link->Y+8)] == CF_SHOVELITEM && !Screen->State[ST_SPECIALITEM]){
							item DugTreasure = CreateItemAt(Screen->RoomData,DirtThrow->X,DirtThrow->Y);
							DugTreasure->Pickup = IP_ST_SPECIALITEM + IP_HOLDUP;
							DugTreasure->Z = 16;
							DugTreasure->Jump = 1.5;
						}

						// --- Dig hidden combos:
						if (Screen->ComboF[ComboAt(Link->X+17,Link->Y+8)] == CF_SHOVELSECRET)
						{
							Game->PlaySound(27);
							Screen->ComboD[ComboAt(Link->X+17,Link->Y+8)] = Screen->RoomData;
						}
						// --- Dig normal dirt:
						else
						{
							if (Screen->ComboS[ComboAt(Link->X+17,Link->Y+8)] != 0) Screen->ComboD[ComboAt(Link->X+17,Link->Y+8)] ++;
							else
							{
								DirtThrow->Misc[MISC_SHOVELFIND] = Rand(16);
								if (!IsSideview()) Screen->ComboD[ComboAt(Link->X+17,Link->Y+8)] = SHOVEL_POTHOLE;
								else Screen->ComboD[ComboAt(Link->X+17,Link->Y+8)] = Screen->UnderCombo;

								// --- Magical Bean Leevers
								if (Link->Item[I_MAGICBEAN])
								{	
									if (NumLWeaponsOf(LW_LEEVER) < 8)
									{
									randoLW = CreateLWeaponAt(LW_LEEVER,ComboX(ComboAt(Link->X+17,Link->Y+8)),ComboY(ComboAt(Link->X+17,Link->Y+8)));
									randoLW->UseSprite(SP_LEEVER);
									randoLW->CSet = Screen->ComboC[ComboAt(Link->X+17,Link->Y+8)];
									randoLW->Damage = 4;
									randoLW = CreateLWeaponAt(LW_WHISTLE,0,0);
									}
								}
							}
						}
					}

					// --- Can't dig:
					else Game->PlaySound(SFX_CLINK);
				}


	// --- Shovel spawns random items
				if (DirtThrow->isValid() && !IsSideview())
				{
					if (DirtThrow->Misc[MISC_SHOVELFIND] >12)
					{
						item DigFound = CreateItemAt(Choose(I_RUPEE1,I_RUPEE1,I_RUPEE1,I_HEART,I_HEART),DirtThrow->X,DirtThrow->Y);
						DigFound->Pickup = IP_TIMEOUT;
						DigFound->Z = 16;
						DigFound->Jump = 1.5;
						DirtThrow->Misc[MISC_SHOVELFIND] = 0;
					}
					if (DirtThrow->Misc[MISC_SHOVELFIND] >= 11 && DirtThrow->Misc[MISC_SHOVELFIND] <= 12)
					{
						item DigFound = CreateItemAt(Choose(I_HEARTTWO,Choose(I_HEARTTWO,I_NEGAHEART,I_RUPEE1),Choose(I_HEARTTWO,I_NEGAHEART),Choose(I_RUPEE1,I_RUPEE5),Choose(I_RUPEE5,I_RUPEE10),Choose(I_NEGAHEART,I_HEART,I_HEARTTWO,I_FAIRY)),DirtThrow->X,DirtThrow->Y);
						DigFound->Pickup = IP_TIMEOUT;
						if (DigFound->ID != I_FAIRY)
						{
							DigFound->Z = 16;
							DigFound->Jump = 1.5;
						}
						else DigFound->Y = DigFound->Y - 16;
						if (DigFound->Y < 1) DigFound->Y = 8;
						DirtThrow->Misc[MISC_SHOVELFIND] = 0;
					}
					if (DirtThrow->Misc[MISC_SHOVELFIND] == 1)
					{
						DirtThrow->Misc[MISC_SHOVELFIND] = Choose (0,0,0,0,0,1);
						if (DirtThrow->Misc[MISC_SHOVELFIND] == 1)
						{
							item DigFound = CreateItemAt(Choose(I_RUPEE1,I_RUPOOR),DirtThrow->X,DirtThrow->Y);
							DigFound->Z = 16;
							DigFound->Jump = 1.5;
							DigFound->Pickup = IP_TIMEOUT;
						}
					}
				}
			}



// --------------------------------------- Chapter 23: Item: Shovel (end)






// --------------------------------------- Chapter 24: Item: Rope (start)
// NOTE: Rope is created and removed via the Item script "RopeItem".

			if (NumLWeaponsOf(LW_ROPE) > 0 && DoDraw)
			{
				if (!RopeWeapon->isValid()) RopeWeapon = LoadLWeaponOf(LW_ROPE);
				if (RopeWeapon->Dir == DIR_LEFT || RopeWeapon->Dir == DIR_RIGHT)
				{
					if (RopeWeapon->X > 8 && RopeWeapon->X < 248)
					{
						if (RopeWeapon->TileWidth == 2 && RopeWeapon->X < 232 || RopeWeapon->TileWidth == 1)
						{
							if (LinkCollision(RopeWeapon))
							{
								if (RopeWeapon->TileWidth == 1)
								{
									if (Screen->ComboS[ComboAt(RopeWeapon->X-1,RopeWeapon->Y+7)] == 0 && Screen->ComboS[ComboAt(RopeWeapon->X+17,RopeWeapon->Y+8)] == 0)
									{
										if (Screen->ComboS[ComboAt(RopeWeapon->X+7,RopeWeapon->Y+8)] != 0)
										{
											if (Link->InputLeft || Link->InputRight)
											{
												if (!IsSideview())
												{
													if (Link->Y < RopeWeapon->Y) Link->Y ++;
													else if (Link->Y > RopeWeapon->Y) Link->Y --;
												}
											}
											if (Link->InputRight){
												if (Screen->ComboS[ComboAt(Link->X+17,Link->Y+8)] != 0 || Screen->ComboS[ComboAt(Link->X+12,Link->Y+8)] != 0) Link->X ++;
											}
											if (Link->InputLeft){
												if (Screen->ComboS[ComboAt(Link->X-1,Link->Y+8)] != 0 || Screen->ComboS[ComboAt(Link->X+4,Link->Y+8)] != 0) Link->X --;
											}
										}
									}
								}
								if (RopeWeapon->TileWidth == 2)
								{
									if (Screen->ComboS[ComboAt(RopeWeapon->X-1,RopeWeapon->Y+8)] == 0 && Screen->ComboS[ComboAt(RopeWeapon->X+33,RopeWeapon->Y+8)] == 0)
									{
										if (Screen->ComboS[ComboAt(RopeWeapon->X+7,RopeWeapon->Y+8)] != 0 || Screen->ComboS[ComboAt(RopeWeapon->X+23,RopeWeapon->Y+8)] != 0)
										{
											if (Link->InputLeft || Link->InputRight)
											{
												if (!IsSideview()) Link->Y = RopeWeapon->Y;
											}
											if (Link->InputRight){
												if (Screen->ComboS[ComboAt(Link->X+17,Link->Y+8)] != 0 || Screen->ComboS[ComboAt(Link->X+12,Link->Y+8)] != 0) Link->X ++;
											}
											if (Link->InputLeft){
												if (Screen->ComboS[ComboAt(Link->X-1,Link->Y+8)] != 0 || Screen->ComboS[ComboAt(Link->X+4,Link->Y+8)] != 0) Link->X --;
											}
										}
									}
								}
							}
						}
					}
				}

				if (RopeWeapon->Dir == DIR_UP || RopeWeapon->Dir == DIR_DOWN)
				{
					if (RopeWeapon->Y > 8 && RopeWeapon->Y < 152)
					{
						if (RopeWeapon->TileHeight == 2 && RopeWeapon->X < 136 || RopeWeapon->TileHeight == 1)
						{
							if (LinkCollision(RopeWeapon))
							{
								if (RopeWeapon->TileHeight == 1)
								{
									if (Screen->ComboS[ComboAt(RopeWeapon->X+7,RopeWeapon->Y-1)] == 0 && Screen->ComboS[ComboAt(RopeWeapon->X+7,RopeWeapon->Y+17)] == 0)
									{
										if (Screen->ComboS[ComboAt(RopeWeapon->X+7,RopeWeapon->Y+8)] != 0)
										{
											if (Link->InputDown || Link->InputUp)
											{
												if (!IsSideview()) 
												{
													if (Link->X < RopeWeapon->X) Link->X++;
													else if (Link->X > RopeWeapon->X) Link->X--;
												}
											}
											if (Link->InputDown){
												if (Screen->ComboS[ComboAt(Link->X+7,Link->Y+17)] != 0 || Screen->ComboS[ComboAt(Link->X+7,Link->Y+4)] != 0) Link->Y ++;
											}
											if (Link->InputUp){
												if (Screen->ComboS[ComboAt(Link->X+7,Link->Y-1)] != 0 || Screen->ComboS[ComboAt(Link->X+7,Link->Y+12)] != 0) Link->Y --;
											}
										}
									}
								}
								if (RopeWeapon->TileHeight == 2)
								{
									if (Screen->ComboS[ComboAt(RopeWeapon->X+7,RopeWeapon->Y-1)] == 0 && Screen->ComboS[ComboAt(RopeWeapon->X+7,RopeWeapon->Y+33)] == 0)
									{
										if (Screen->ComboS[ComboAt(RopeWeapon->X+7,RopeWeapon->Y+8)] != 0 || Screen->ComboS[ComboAt(RopeWeapon->X+7,RopeWeapon->Y+24)] != 0)
										{
											if (Link->InputDown || Link->InputUp)
											{
												if (!IsSideview())
												{
													if (Link->X < RopeWeapon->X) Link->X++;
													else if (Link->X > RopeWeapon->X) Link->X--;
												}
											}
											if (Link->InputDown)
											{
												if (Screen->ComboS[ComboAt(Link->X+7,Link->Y+17)] != 0 || Screen->ComboS[ComboAt(Link->X+7,Link->Y+4)] != 0) Link->Y ++;
											}
											if (Link->InputUp)
											{
												if (Screen->ComboS[ComboAt(Link->X+7,Link->Y-1)] != 0 || Screen->ComboS[ComboAt(Link->X+7,Link->Y+12)] != 0) Link->Y --;
											}
										}
									}
								}
							}
						}
					}
				}

				if (IsSideview())
				{
					if (RopeWeapon->Y >= 160 - (16 * (RopeWeapon->TileHeight-1))) RopeWeapon->Y ++;
					if (RopeWeapon->TileHeight == 1 && RopeWeapon->TileWidth == 1)
					{
						if (CanWalk(RopeWeapon->X,RopeWeapon->Y,DIR_DOWN,1,true))
						{
							if (!SomariaBlock->isValid() || !Collision(SomariaBlock,RopeWeapon) || RopeWeapon->Y > SomariaBlock->Y)  RopeWeapon->Y ++;
						}
					}
					else if (RopeWeapon->TileHeight == 2)
					{
						if (CanWalk(RopeWeapon->X,RopeWeapon->Y+16,DIR_DOWN,1,true))
						{
							if (!SomariaBlock->isValid() || !Collision(SomariaBlock,RopeWeapon) || RopeWeapon->Y+16 > SomariaBlock->Y)  RopeWeapon->Y ++;
						}
					}
					else if (RopeWeapon->TileWidth == 2) 
					{
						if (CanWalk(RopeWeapon->X,RopeWeapon->Y,DIR_DOWN,1,true) && CanWalk(RopeWeapon->X+16,RopeWeapon->Y,DIR_DOWN,1,true))
						{
							if (!SomariaBlock->isValid() || !Collision(SomariaBlock,RopeWeapon) || RopeWeapon->Y+16 > SomariaBlock->Y) RopeWeapon->Y ++;
						}
					}
					if (Link->X > RopeWeapon->X-12 && Link->X < RopeWeapon->X+12+(16*(RopeWeapon->TileWidth-1)) && Link->Y > RopeWeapon->Y-16 && Link->Y < RopeWeapon->Y+16*RopeWeapon->TileHeight)
					if (LinkCollision(RopeWeapon))
					{
						Link->Jump = 0;
						if (!Link->InputB && !Link->InputA)
						{
							if (Link->InputUp && CanWalk(Link->X,Link->Y,DIR_UP,1,false) && Link->Y > RopeWeapon->Y-15) Link->Y --;
							else if (Link->InputDown && CanWalk(Link->X,Link->Y,DIR_DOWN,1,false)) Link->Y ++;
						}
					}
				}
			}


// --------------------------------------- Chapter 24: Item: Rope (end)







// --------------------------------------- Chapter 25: Link (Zelda) falls like a rock in sideview (start)
// Deliberately primitive, Lode runner-esque falling movement

			if (Link->Jump < 0)
			{
				if (IsSideview())
				{
					if (Screen->ComboT[ComboAt(Link->X+7,Link->Y+17)] != CT_SIDECLIMB && Screen->ComboT[ComboAt(Link->X+7,Link->Y+8)] != CT_SIDECLIMB)
					{
						if (PegasusTimer == 0){
							if (!RopeWeapon->isValid() || !LinkCollision(RopeWeapon))
							{
								if (!FallSound)
								{
									if (Screen->ComboS[ComboAt(Link->X+7,Link->Y+28)] == 0)
									{
										Game->PlaySound(SFX_PLAYERFALL);
										FallSound = true;
									}
								}
								Link->InputLeft = false;
								Link->InputRight = false;
							}
						}
					}
				}
			}
			else if (FallSound) FallSound = false;

// --------------------------------------- Chapter 25: Link (Zelda) falls like a rock in sideview (end)







// --------------------------------------- Chapter 26: Item: Beetle (start)
			if (Link->InputB && GetEquipmentB() == I_BEETLE || Link->InputA && GetEquipmentA() == I_BEETLE || Link->InputB && GetEquipmentB() == I_STRONGBEETLE || Link->InputA && GetEquipmentA() == I_STRONGBEETLE)
			{
				if (!DeadBeetle && DoDraw)
				{
					if (Link->Action < 3)
					{
						Link->Action = LA_NONE;
						Link->Action = LA_ATTACKING;
					}
					if (!Beetle->isValid())
					{
						if (Link->PressB && GetEquipmentB() == I_BEETLE || Link->PressB && GetEquipmentB() == I_STRONGBEETLE || Link->PressA && GetEquipmentA() == I_BEETLE || Link->PressA && GetEquipmentA() == I_STRONGBEETLE)
						{
							Beetle = CreateLWeaponAt(LW_BEETLE,Link->X,Link->Y);
							Game->PlaySound(SFX_BEETLE);
							if (!Link->Item[I_STRONGBEETLE]) Beetle->UseSprite(SP_BEETLE);
							else Beetle->UseSprite(SP_STRONGBEETLE);
							Beetle->Dir = Link->Dir;
			// these ->Flip commands are disabled for the Keese, but if you remove the comment lines (//) they will work.
			// 				if (Link->Dir == DIR_UP) Beetle->Flip = FLIP_VERTICAL;
			// 				if (Link->Dir == DIR_LEFT) Beetle->Flip = ROT_CW;
			// 				if (Link->Dir == DIR_RIGHT) Beetle->Flip = ROT_CCW;
						}
					}
	//------ Beetle steering
					if (Link->InputUp)
					{
						Beetle->Dir = DIR_UP;
			 			//if (!BeetleCarrying) Beetle->Flip = FLIP_VERTICAL;
					}
					if (Link->InputDown)
					{
						Beetle->Dir = DIR_DOWN;
						//if (!BeetleCarrying) Beetle->Flip = FLIP_NONE;
					}
					if (Link->InputLeft)
					{
						Beetle->Dir = DIR_LEFT;
						//if (!BeetleCarrying) Beetle->Flip = ROT_CW;
					}
					if (Link->InputRight)
					{
						Beetle->Dir = DIR_RIGHT;
						//if (!BeetleCarrying) Beetle->Flip = ROT_CCW;
					}
					if (Link->InputUp && Link->InputLeft) Beetle->Dir = DIR_LEFTUP;
					if (Link->InputDown && Link->InputLeft) Beetle->Dir = DIR_LEFTDOWN;
					if (Link->InputUp && Link->InputRight) Beetle->Dir = DIR_RIGHTUP;
					if (Link->InputDown && Link->InputRight) Beetle->Dir = DIR_RIGHTDOWN;

					if (Beetle->Dir == DIR_UP && Beetle->Y > 2)
					{
						if (Beetle->Y > Link->Y-BEETLE_RANGE || Link->Item[I_STRONGBEETLE]) Beetle->Y --;
					}
					if (Beetle->Dir == DIR_LEFT && Beetle->X > 4)
					{
						if (Beetle->X > Link->X-BEETLE_RANGE || Link->Item[I_STRONGBEETLE]) Beetle->X --;
					}
					if (Beetle->Dir == DIR_RIGHT && Beetle->X < 236)
					{
						if (Beetle->X < Link->X+BEETLE_RANGE || Link->Item[I_STRONGBEETLE]) Beetle->X ++;
					}
					if (Beetle->Dir == DIR_DOWN && Beetle->Y < 158)
					{
						if (Beetle->Y < Link->Y+BEETLE_RANGE || Link->Item[I_STRONGBEETLE]) Beetle->Y ++;
					}
					if (Beetle->Dir == DIR_LEFTUP && Beetle->X > 4 && Beetle->Y > 2)
					{
						if (Beetle->X > Link->X-BEETLE_RANGE || Link->Item[I_STRONGBEETLE]) Beetle->X --;
						if (Beetle->Y > Link->Y-BEETLE_RANGE || Link->Item[I_STRONGBEETLE]) Beetle->Y --;
					}
					if (Beetle->Dir == DIR_LEFTDOWN && Beetle->X > 4 && Beetle->Y < 158)
					{
						if (Beetle->X > Link->X-BEETLE_RANGE || Link->Item[I_STRONGBEETLE]) Beetle->X --;
						if (Beetle->Y < Link->Y+BEETLE_RANGE || Link->Item[I_STRONGBEETLE]) Beetle->Y ++;
					}
					if (Beetle->Dir == DIR_RIGHTUP && Beetle->X < 236 && Beetle->Y > 4)
					{
						if (Beetle->X < Link->X+BEETLE_RANGE || Link->Item[I_STRONGBEETLE]) Beetle->X ++;
						if (Beetle->Y > Link->Y-BEETLE_RANGE || Link->Item[I_STRONGBEETLE]) Beetle->Y --;
					}
					if (Beetle->Dir == DIR_RIGHTDOWN && Beetle->X < 236 && Beetle->Y < 158)
					{
						if (Beetle->X < Link->X+BEETLE_RANGE || Link->Item[I_STRONGBEETLE]) Beetle->X ++;
						if (Beetle->Y < Link->Y+BEETLE_RANGE || Link->Item[I_STRONGBEETLE]) Beetle->Y ++;
					}

	//------ Beetle Carries LWeapons
					for(ForTimer = Screen->NumLWeapons(); ForTimer > 0; ForTimer--)
					{
						randoLW = Screen->LoadLWeapon(ForTimer);
						if(!randoLW->isValid()) continue;
						{
							if (randoLW->ID != LW_BOMBBLAST && randoLW->ID != LW_SBOMBBLAST)
							{
								if (Collision(Beetle,randoLW))
								{
									if (randoLW->ID != LW_BEETLE && randoLW->ID != LW_CANEOFBYRNA && !BeetleCarrying){
										BeetleCarrying = true;
										Beetle->Flip = FLIP_NONE;
										if (GetEquipmentB() == I_BEETLE || GetEquipmentA() == I_BEETLE) Beetle->UseSprite(SP_BEETLECARRY);
										if (GetEquipmentB() == I_STRONGBEETLE || GetEquipmentA() == I_STRONGBEETLE) Beetle->UseSprite(SP_STRONGCARRY);
										BeetleLW = randoLW;
									}
								}
							}
						}
					}
					if (BeetleLW->ID != LW_BOMBBLAST && BeetleLW->ID != LW_SBOMBBLAST)
					{
						if (Collision(Beetle,BeetleLW))
						{
							BeetleLW->X = Beetle->X;
							BeetleLW->Dir = Beetle->Dir;
							if (!IsSideview() ||BeetleLW->ID != LW_SOMARIA || Link->Item[I_STRONGBEETLE]) BeetleLW->Y = Beetle->Y+6;
						}
					}
	//------ Beetle Carries EWeapons
					for(ForTimer = Screen->NumEWeapons(); ForTimer > 0; ForTimer--)
					{
						randoEW = Screen->LoadEWeapon(ForTimer);
						if(!randoEW->isValid()) continue;
						{
							if (randoEW->ID != EW_BOMBBLAST && randoEW->ID != EW_SBOMBBLAST)
							{
								if (Collision(Beetle,randoEW))
								{
									if (!BeetleCarrying)
									{
										BeetleCarrying = true;
										Beetle->Flip = FLIP_NONE;
										if (GetEquipmentB() == I_BEETLE || GetEquipmentA() == I_BEETLE) Beetle->UseSprite(SP_BEETLECARRY);
										if (GetEquipmentB() == I_STRONGBEETLE || GetEquipmentA() == I_STRONGBEETLE) Beetle->UseSprite(SP_STRONGCARRY);
										if (randoEW->ID == EW_BOMB)
										{
											BeetleLW = CreateLWeaponAt(LW_BOMB,Beetle->X,Beetle->Y+6);
											BeetleLW->Damage = 6;
											//BeetleLW->CSet = randoEW->CSet;
											Remove(randoEW);
										}
										if (randoEW->ID == EW_SBOMB)
										{
											BeetleLW = CreateLWeaponAt(LW_SBOMB,Beetle->X,Beetle->Y+6);
											BeetleLW->Damage = 10;
											//BeetleLW->CSet = randoEW->CSet;
											Remove(randoEW);
										}
										BeetleEW = randoEW;
									}
								}
							}
						}
					}
					if (Collision(Beetle,BeetleEW))
					{
						BeetleEW->X = Beetle->X;
						BeetleEW->Dir = Beetle->Dir;
						BeetleEW->Y = Beetle->Y+6;

						// Stationary bombs will be turned into LW_BOMBs when their fuse reaches 9998
						if (BeetleEW->ID == EW_STATIONARYBOMB) BeetleEW->Misc[MISC_STATIONARYFUSE] = 10000;

					}

	//------ Beetle Carries Items
					for(ForTimer = Screen->NumItems(); ForTimer > 0; ForTimer--)
					{
						randoitem = Screen->LoadItem(ForTimer);
						if(!randoitem->isValid()) continue;
						{
							if (Collision(Beetle,randoitem)){
								if (!BeetleCarrying){
									BeetleCarrying = true;
									Beetle->Flip = FLIP_NONE;
									if (GetEquipmentB() == I_BEETLE || GetEquipmentA() == I_BEETLE) Beetle->UseSprite(SP_BEETLECARRY);
									if (GetEquipmentB() == I_STRONGBEETLE || GetEquipmentA() == I_STRONGBEETLE) Beetle->UseSprite(SP_STRONGCARRY);
									BeetleItem = randoitem;
								}
							}
						}
					}
					if (Collision(Beetle,BeetleItem))
					{
						BeetleItem->X = Beetle->X;
						BeetleItem->Y = Beetle->Y+6;
					}
	//------ Beetle triggers secrets on Strike (any weapon) flag
					if (Screen->ComboF[ComboAt(Beetle->X+7,Beetle->Y+8)] == CF_STRIKE)
					{
						Screen->TriggerSecrets();
						if (Screen->Flags[SF_SECRETS]&0x0004) Screen->State[ST_SECRET] = true;
						Game->PlaySound(27);
						Beetle->DeadState = WDS_DEAD;
					}
	//------ Beetle Can't pass CT_BLOCKALL or left or right statue combos
					if (Screen->ComboT[ComboAt(Beetle->X+7,Beetle->Y+8)] == CT_BLOCKALL) Beetle->DeadState = WDS_DEAD;
					if (Screen->ComboT[ComboAt(Beetle->X+7,Beetle->Y+8)] == CT_LEFTSTATUE) Beetle->DeadState = WDS_DEAD;
					if (Screen->ComboT[ComboAt(Beetle->X+7,Beetle->Y+8)] == CT_RIGHTSTATUE) Beetle->DeadState = WDS_DEAD;
				}
			}
	//------ Beetle destroyed or deactivated
			else
			{
				if (Beetle->isValid()) Remove(Beetle);
				if (DeadBeetle) DeadBeetle = false;
				if (BeetleCarrying) BeetleCarrying = false;
			}

			if (Beetle->isValid() && Beetle->DeadState != WDS_ALIVE && !DeadBeetle)
			{
				DeadBeetle = true;
				lweapon BeetlePoof = CreateLWeaponAt(LW_SPARKLE,Beetle->X,Beetle->Y);
				BeetlePoof->UseSprite(SP_BEETLEPOOF);
			}

// --------------------------------------- Chapter 26: Item: Beetle (end)







// --------------------------------------- Chapter 27: Windy Screens (start)
// Maybe this should've been an FFC script?

			if (Screen->Flags[9]&0x0020 && Link->Action != LA_SCROLLING) 	//"Screen->Screen Data->Sflags 2->General Use 4 (Scripts)" checkbox.
			{
				if (WindyTimer == 0){
					WindyTimer = 8;
					Game->PlaySound(SFX_WINDY);
				}
				else WindyTimer --;

	// --- Blowing Up
				if (Screen->RoomData == 1 || Screen->RoomData == 5){
					if (NumLWeaponsOf(LW_SPARKLE) < 8) 
					{
						lweapon WindyWoosh = CreateLWeaponAt(LW_SPARKLE,(Rand(15)*16),152);
						WindyWoosh->UseSprite(SP_WINDY);
						if (Screen->RoomData == 1) WindyWoosh->Step = Rand(300,800);
						else
							{
								WindyWoosh->CSet = 8;
								WindyWoosh->Step = Rand(300,500);
							}
						WindyWoosh->Dir = DIR_UP;
					}
					if (!(WindyTimer%2))
					{
						if (Screen->RoomData == 1 && Link->Item[I_BOOTS] && Link->Action == LA_WALKING || Screen->RoomData == 5 && !Link->Item[I_BOOTS])
						{
							PushLink(DIR_UP);
							Link->InputLeft = false;
							Link->InputRight = false;
						}
					}
					if (Screen->RoomData == 1)
					{
						if (!Link->Item[I_BOOTS] || Link->Action != LA_WALKING) PushLink(DIR_UP);
						if (!Link->Item[I_BOOTS] || Link->InputUp)
						{
							Link->InputDown = false;
							PushLink(DIR_UP);
						}
					}
				}


	// --- Blowing Down
				if (Screen->RoomData == 2 || Screen->RoomData == 6){
					if (NumLWeaponsOf(LW_SPARKLE) < 8) 
					{
						lweapon WindyWoosh = CreateLWeaponAt(LW_SPARKLE,Rand(15)*16,8);
						WindyWoosh->UseSprite(SP_WINDY);
						if (Screen->RoomData == 2) WindyWoosh->Step = Rand(300,800);
						else
							{
								WindyWoosh->CSet = 8;
								WindyWoosh->Step = Rand(300,500);
							}
						WindyWoosh->Dir = DIR_DOWN;
					}
					if (!(WindyTimer%2))
					{
						if (Screen->RoomData == 2 && Link->Item[I_BOOTS] && Link->Action == LA_WALKING || Screen->RoomData == 6 && !Link->Item[I_BOOTS])
						{
							PushLink(DIR_DOWN);
							Link->InputLeft = false;
							Link->InputRight = false;
						}
					}
					if (Screen->RoomData == 2)
					{
						if (!Link->Item[I_BOOTS] || Link->Action != LA_WALKING) PushLink(DIR_DOWN);
						if (!Link->Item[I_BOOTS] || Link->InputDown)
						{
							Link->InputUp = false;
							PushLink(DIR_DOWN);
						}
					}
				}

	// --- Blowing Left
				if (Screen->RoomData == 3 || Screen->RoomData == 7){
					if (NumLWeaponsOf(LW_SPARKLE) < 8) 
					{
						lweapon WindyWoosh = CreateLWeaponAt(LW_SPARKLE,236,Rand(10)*16);
						WindyWoosh->UseSprite(SP_WINDY);
						if (Screen->RoomData == 3) WindyWoosh->Step = Rand(300,800);
						else
							{
								WindyWoosh->CSet = 8;
								WindyWoosh->Step = Rand(300,500);
							}
						WindyWoosh->Dir = DIR_LEFT;
					}
					if (!(WindyTimer%2)) 
					{
						if (Screen->RoomData == 3 && Link->Item[I_BOOTS] && Link->Action == LA_WALKING || Screen->RoomData == 7 && !Link->Item[I_BOOTS])
						{
							PushLink(DIR_LEFT);
							Link->InputUp = false;
							Link->InputDown = false;
						}
					}
					if (Screen->RoomData == 3)
					{
						if (!Link->Item[I_BOOTS] || Link->Action != LA_WALKING) PushLink(DIR_LEFT);
						if (!Link->Item[I_BOOTS] || Link->InputLeft)
						{
							Link->InputRight = false;
							PushLink(DIR_LEFT);
						}
					}
				}

	// --- Blowing Right
				if (Screen->RoomData == 4 || Screen->RoomData == 8){
					if (NumLWeaponsOf(LW_SPARKLE) < 8)
					{
						lweapon WindyWoosh = CreateLWeaponAt(LW_SPARKLE,4,Rand(10)*16);
						WindyWoosh->UseSprite(SP_WINDY);
						if (Screen->RoomData == 4) WindyWoosh->Step = Rand(300,800);
						else
							{
								WindyWoosh->CSet = 8;
								WindyWoosh->Step = Rand(300,500);
							}
						WindyWoosh->Dir = DIR_RIGHT;
					}
					if (!(WindyTimer%2))
					{
						if (Screen->RoomData == 4 && Link->Item[I_BOOTS] && Link->Action == LA_WALKING || Screen->RoomData == 8 && !Link->Item[I_BOOTS])
						{
							PushLink(DIR_RIGHT);
							Link->InputUp = false;
							Link->InputDown = false;
						}
					}
					if (Screen->RoomData == 4)
					{
						if (!Link->Item[I_BOOTS] || Link->Action != LA_WALKING) PushLink(DIR_RIGHT);
						if (!Link->Item[I_BOOTS] || Link->InputRight)
						{
							Link->InputLeft = false;
							PushLink(DIR_RIGHT);
						}
					}
				}

			}
// --------------------------------------- Chapter 27: Windy Screens (end)











// --------------------------------------- Chapter 28: Call FourWayCurse
			if (!IsSideview()) FourWayCurse(0);







// --------------------------------------- Chapter 29: Item: Lantern (start)
// Maybe this should be redone to launch an FFC script?

			if (Screen->Flags[9]&0x0040) 	//"Screen->Screen Data->Sflags 2->General Use 5 (Scripts)" checkbox.
			{
				if (!IsDark) IsDark = true;
			}
			else if (IsDark && Link->Action != LA_SCROLLING) IsDark = false;
			if (IsDark)
			{	

				if (Link->Action == LA_SCROLLING || !Link->Item[I_LANTERN]) 
				{
					Screen->Rectangle(
							5,	//layer
							0,	//start X
							0,	//start y
							256,	//end x
							176,	//end y
							0,1,0,0,0,true,128);

	// --- Extra draw beacuse subscreen interrupts high layered draws
					Screen->Rectangle(
							2,	//layer
							0,	//start X
							0,	//start y
							256,	//end x
							176,	//end y
							0,1,0,0,0,true,128);			

					if (Link->Action != LA_SCROLLING) Screen->DrawTile(
							6,
							Link->X,	//start X
							Link->Y-Link->Z,//start y
							Link->Tile,	//tile ID
							1,		//tile width
							1,		//tile width
							6,		//tile cset
							-1,-1,-1,-1,0,Link->Flip,1,128);
	

				}

				if (Link->Action != LA_SCROLLING && Link->Item[I_LANTERN])
				{


					Screen->Rectangle(
							6,		//layer
							0,		//start X
							0,		//start y
							256,		//end x
							Link->Y-32,	//end y
							0,1,0,0,0,true,128);	
					Screen->Rectangle(
							6,		//layer
							0,		//start X
							Link->Y+48,	//start y
							256,		//end x
							176,		//end y
							0,1,0,0,0,true,128);	
					Screen->Rectangle(
							6,		//layer
							0,		//start X
							0,		//start y
							Link->X-32,	//end x
							176,		//end y
							0,1,0,0,0,true,128);	
					Screen->Rectangle(
							6,		//layer
							Link->X+48,	//start X
							0,		//start y
							256,		//end x
							176,		//end y
							0,1,0,0,0,true,128);	
					Screen->DrawTile(
							6,
							Link->X-32,	//start X
							Link->Y-32,	//start y
							LANTERN_TILE,	//tile ID
							5,		//tile width
							5,		//tile width
							0,		//tile cset
							-1,-1,-1,-1,0,0,1,128);


	// --- Extra draws because subscreen interrupts higher layered draws
	// Maybe there's a better way to do it though?

					Screen->Rectangle(
							2,		//layer
							0,		//start X
							0,		//start y
							256,		//end x
							Link->Y-32,	//end y
							0,1,0,0,0,true,128);	
					Screen->Rectangle(
							2,		//layer
							0,		//start X
							Link->Y+48,	//start y
							256,		//end x
							176,		//end y
							0,1,0,0,0,true,128);	
					Screen->Rectangle(
							2,		//layer
							0,		//start X
							0,		//start y
							Link->X-32,	//end x
							176,		//end y
							0,1,0,0,0,true,128);	
					Screen->Rectangle(
							2,		//layer
							Link->X+48,	//start X
							0,		//start y
							256,		//end x
							176,		//end y
							0,1,0,0,0,true,128);	



				}
			}
// --------------------------------------- Chapter 29: Item: Lantern (end)






// --------------------------------------- Chapter 30: Waitdraw()
			Waitdraw();













		}		
// -----------------------------------------------------------------------
// End of Global While() loop
// -----------------------------------------------------------------------


	}
}


// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// Global script (End)
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------














// ---------------------------------------------- Section 5: Item SCripts

// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
// Cane of Somaria Item script (Start)
// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
// NOTE: Actual push of the Somaria block is in the Global script, not this item script. See "Somaria pushblock" section of global.


item script SomariaCane
{
	void run(int Damage, int Color, int NoSpawnCombo)
//D0 - Damage for blocks and beams to deal.
//D1 - Color of blocks.
//D2 - Will not spawn blocks on top of D2 combo type.

	{
		lweapon SomariaBlock;
		lweapon SomariaGoesPoof;
		lweapon Sword;
		if (NumLWeaponsOf(LW_SOMARIA) == 0)
		{
			if (NoSpawnCombo == 0 || Link->Dir == DIR_UP && Screen->ComboT[ComboAt(Link->X+7,Link->Y - 4)] != NoSpawnCombo || Link->Dir == DIR_DOWN && Screen->ComboT[ComboAt(Link->X+7,Link->Y + 20)] != NoSpawnCombo || Link->Dir == DIR_LEFT && Screen->ComboT[ComboAt(Link->X-4,Link->Y+8)] != NoSpawnCombo || Link->Dir == DIR_RIGHT && Screen->ComboT[ComboAt(Link->X+20,Link->Y+8)] != NoSpawnCombo)
			{
				SomariaBlock = NextToLink(LW_SOMARIA,0);
				SomariaBlock->UseSprite(SP_SOMARIABLOCK);
				SomariaBlock->CSet = Color;
				SomariaBlock->Damage = Damage;	
				SomariaBlock->Dir = Link->Dir;
				SomariaGoesPoof = CreateLWeaponAt(LW_SPARKLE,SomariaBlock->X,SomariaBlock->Y);
				SomariaGoesPoof->UseSprite(SP_SPAWN);
				Game->PlaySound(SFX_SOMARIA);
			}
		}
		else
		{
			SomariaBlock = LoadLWeaponOf(LW_SOMARIA);
			SomariaGoesPoof = CreateLWeaponAt(LW_SPARKLE,SomariaBlock->X,SomariaBlock->Y);
			SomariaGoesPoof->UseSprite(SP_MISC_DEATH);
			Game->PlaySound(SFX_SOMARIA);
			if (Link->Item[I_SOMARIABOOK] && Link->HP >= Link->MaxHP-4)
			{
				if (NumLWeaponsOf(LW_BEAM) == 0)
				{
					lweapon SomariaBeam = CreateLWeaponAt(LW_BEAM,SomariaBlock->X,SomariaBlock->Y);
					SomariaBeam->UseSprite(SP_SOMARIABEAM);
					SomariaBeam->Damage = Damage;

					lweapon SomariaBeam2 = CreateLWeaponAt(LW_BEAM,SomariaBlock->X,SomariaBlock->Y);
					SomariaBeam2->UseSprite(SP_SOMARIABEAM);
					SomariaBeam2->Damage = Damage;
					SomariaBeam2->Dir = DIR_DOWN;
					SomariaBeam2->Flip = FLIP_VERTICAL;

					lweapon SomariaBeam3 = CreateLWeaponAt(LW_BEAM,SomariaBlock->X,SomariaBlock->Y);
					SomariaBeam3->UseSprite(SP_SOMARIABEAM);
					SomariaBeam3->Damage = Damage;
					SomariaBeam3->Dir = DIR_LEFT;
					SomariaBeam3->Flip = ROT_CW_FLIP;

					lweapon SomariaBeam4 = CreateLWeaponAt(LW_BEAM,SomariaBlock->X,SomariaBlock->Y);
					SomariaBeam4->UseSprite(SP_SOMARIABEAM);
					SomariaBeam4->Damage = Damage;
					SomariaBeam4->Dir = DIR_RIGHT;
					SomariaBeam4->Flip = ROT_CW;

					Game->PlaySound(SFX_BEAM);
				}
			}
			Remove(SomariaBlock);
		}
	}
}

// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
// Cane of Somaria Item script (End)
// --------------------------------------------------------------------------
// --------------------------------------------------------------------------








// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
// Ally NPC / Octorok Item script (Start)
// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
// NOTE: LWeapons are created by the global script


item script AllyNPC
{
	void run(int OctoSummon, int OctoColor, int OctoLWeapon, int OctoDamage, int OctoLWeaponSprite)
	{

	// D0: NPC to summon.
	// D1: CSet of NPC
	// D2: LWeapon for NPC to fire (if 0, no weapon)
	// D3: Damage of NPC's weapons

		npc GoodOcto = LoadNPCOf(OctoSummon);
		if (GoodOcto->isValid())
		{
			GoodOcto->HP = HP_SILENT;
			Game->PlaySound(SFX_MSG);
		}
		else
		{
			GoodOcto = CreateNPCAt(OctoSummon,ComboX(ComboAt(Link->X,Link->Y)),ComboY(ComboAt(Link->X,Link->Y)));
			GoodOcto->CSet = OctoColor;
			GoodOcto->WeaponDamage = OctoDamage;
			GoodOcto->CollDetection = 0;
			GoodOcto->Dir = Link->Dir;
			if (OctoLWeapon == 0) GoodOcto->Weapon = 0;
			else
			{
				GoodOcto->Misc[MISC_NPCLWEAPON] = OctoLWeapon;
				GoodOcto->Misc[MISC_NPCLWEAPONSPRITE] = OctoLWeaponSprite;
				GoodOcto->Misc[MISC_NPCLWEAPONTIMER] = Rand(128);
			}
			Game->PlaySound(SFX_SOMARIA);
		}
	}
}

// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
// Ally NPC / Octorok Item script (End)
// --------------------------------------------------------------------------
// --------------------------------------------------------------------------












// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
// "Item Creates LWeapon" Item Script (Start)
// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
// NOTE: Used to create/destroy Item: Bola and Item: Armos. Bola and Armos movement are controlled in the global.
// For Bola details, see also: "Item: Bola movement"
// For Armos details, see also: "Item: Armos movement". "Item: Armos", and "Can be pushed by Armos LWeapons"


item script ItemCreatesLWeapon
{
	void run(int LWeaponToMake, int LWeaponSprite, int LWeaponDamage, int LWeaponStep, int MaxNumber, int LWeaponSFX, int WhereToMake, int RupyCost)
	{

	// D0: LWeapon to create.
	// D1: LWeapon Sprite.
	// D2: LWeapon Damage.
	// D3: LWeapon Step speed.
	// D4: Maximum number of this LWeapon to make; 0 for infinite (spammable).
	// D5: SFX to play.
	// D6: If 1, is created on Link. Otherwise is created one space in front of Link.
	// D7: Item costs D7 rupies to use. (Yes I know it's spelled Rupee/Rupees outside of Zelda 1)


		if (RupyCost == 0 || Game->Counter[CR_RUPEES] >= RupyCost)
		{
			if (NumLWeaponsOf(LWeaponToMake) < MaxNumber || MaxNumber == 0)
			{
				if (RupyCost > 0) Game->DCounter[CR_RUPEES] = Game->DCounter[CR_RUPEES]- RupyCost;
				lweapon TossWeapon = NextToLink(LWeaponToMake,0);
				if (WhereToMake == 1)
				{
					TossWeapon->X = Link->X; 
					TossWeapon->Y = Link->Y;
				}
				TossWeapon->UseSprite(LWeaponSprite);
				TossWeapon->Damage = LWeaponDamage;
				TossWeapon->Step = LWeaponStep;
				TossWeapon->Dir = Link->Dir;
				Link->Action = LA_ATTACKING;
				Game->PlaySound(LWeaponSFX);
			}
		}
	}
}
		
// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
// "Item Creates LWeapon" Item Script (End)
// --------------------------------------------------------------------------
// --------------------------------------------------------------------------


		



// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// "Byrna startup sound" script (start)
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// Because I wanted the Cane of Byrna to make a noise, but not continuously.

item script ByrnaSound
{
	void run(int SoundToMake)
	{
		if (NumLWeaponsOf(LW_CANEOFBYRNA) == 0) Game->PlaySound(SoundToMake);
	}
}
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// "Item startup noise" script (end)
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------







// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
// Rope Item script (Start)
// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
// NOTE: Actual climbing capabilities of the rope are in the Global script, not this item script.


item script RopeItem
{
	void run(int Length, int SP_ROPEVERTICAL, int SP_ROPEHORIZONTAL, int SP_ROPEUPLONG, int SP_ROPEDOWNLONG, int SP_ROPELEFTLONG, int SP_ROPERIGHTLONG, int PoofingRope)
	{

	// D0: Length of rope. 0-1 for 1 tile, 2 or greater for 2 tiles.
	// D1: Weapon Sprite ID for 1x1 rope (vertical).
	// D2: Weapon Sprite ID for 1x1 rope (horizontal).
	// D3: Weapon Sprite ID for two-tile rope (facing up).
	// D4: Weapon Sprite ID for two-tile rope (facing down).
	// D5: Weapon Sprite ID for two-tile rope (facing left).
	// D6: Weapon Sprite ID for two-tile rope (facing right).
	// D7: if > 0, Weapon will poof in and out of existence.

		if (Link->Action != LA_SWIMMING && Link->Action != LA_HOLD1WATER && Link->Action != LA_HOLD2WATER) Link->Action = LA_ATTACKING;

		lweapon NewRope;
		NewRope = LoadLWeaponOf(LW_ROPE);

//----------- Remove an old rope
		if (NewRope->isValid())
		{
			if (Screen->ComboS[ComboAt(Link->X+7,Link->Y+8)] == 0 || !LinkCollision(NewRope))
			{
				if (Length < 2 || NewRope->TileWidth > 1 || NewRope->TileHeight > 1){
					if (PoofingRope > 0)
					{
						lweapon	RopePoof = CreateLWeaponAt(LW_SPARKLE,NewRope->X+((NewRope->TileWidth-1)*8),NewRope->Y+((NewRope->TileHeight-1)*8));
						RopePoof->UseSprite(SP_MISC_DEATH);
						Game->PlaySound(SFX_ROPE);
					}
					Remove(NewRope);
				}

//----------- Extend-o-rope
				if (Length >= 2 && NewRope->TileWidth == 1 && NewRope->TileHeight == 1)
				{
					NewRope->Extend = 3;
					Game->PlaySound(SFX_CHARGE2);
					if (NewRope->Dir == DIR_LEFT || NewRope->Dir == DIR_RIGHT)
					{
						NewRope->TileWidth = 2;
						NewRope->HitWidth = 32;
						if (NewRope->Dir == DIR_LEFT) NewRope->X = NewRope->X - 16;
					}
					else
					{
						NewRope->TileHeight = 2;
						NewRope->HitHeight = 32;
						if (NewRope->Dir == DIR_UP) NewRope->Y = NewRope->Y - 16;
					}
					//if (!IsSideview()) NewRope->X = ComboX(ComboAt(NewRope->X+7,NewRope->Y+8));
					//if (!IsSideview()) NewRope->Y = ComboY(ComboAt(NewRope->X+7,NewRope->Y+8));
					NewRope->Flip = FLIP_NONE;
					if (NewRope->Dir == DIR_UP) NewRope->UseSprite(SP_ROPEUPLONG);
					if (NewRope->Dir == DIR_DOWN) NewRope->UseSprite(SP_ROPEDOWNLONG);
					if (NewRope->Dir == DIR_LEFT) NewRope->UseSprite(SP_ROPELEFTLONG);
					if (NewRope->Dir == DIR_RIGHT) NewRope->UseSprite(SP_ROPERIGHTLONG);
				}
			}
		}


//----------- Create a new rope

		else
		{
			NewRope = NextToLink(LW_ROPE,0);
			NewRope->CollDetection = false;

			NewRope->Dir = Link->Dir;
			if (NewRope->Dir == DIR_UP || NewRope->Dir == DIR_DOWN) NewRope->UseSprite(SP_ROPEVERTICAL);
			//if (NewRope->Dir == DIR_DOWN) NewRope->Flip = FLIP_VERTICAL;
			if (NewRope->Dir == DIR_LEFT || NewRope->Dir == DIR_RIGHT) NewRope->UseSprite(SP_ROPEHORIZONTAL);
			if (NewRope->Dir == DIR_LEFT) NewRope->Flip = FLIP_HORIZONTAL;
			if (!IsSideview()) NewRope->X = ComboX(ComboAt(NewRope->X+7,NewRope->Y+8));
			if (!IsSideview()) NewRope->Y = ComboY(ComboAt(NewRope->X+7,NewRope->Y+8));
			NewRope->HitHeight = 16;
			NewRope->HitWidth = 16;
			if (PoofingRope > 0)
			{
				lweapon	RopePoof = CreateLWeaponAt(LW_SPARKLE,NewRope->X,NewRope->Y);
				RopePoof->UseSprite(SP_SPAWN);
				Game->PlaySound(SFX_ROPE);
			}
		}
	}
}
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// Rope Item script (End)
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------













// ---------------------------------------------- Section 6: FFC scripts

// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
// FFC script: Crazy Patras (start) UNFINISHED WIP
// --------------------------------------------------------------------------
// --------------------------------------------------------------------------

ffc script CrazyPatra
{
	void run(int WhatID, int WhatEyeD, int NumEyes, int WhichPattern, int PatternSize, int EyeGrow)
	{
//D0 - ID of main Patra Core.
//D1 - Patra eyes to spawn
//D2 - How many eyes to spawn
//D3 - Choose a pattern.
		//0 - Triangle
		//1 - Upside down Triangle
		//2 - Square
		//3 - Diamond
//D5 - Pattern shrink/grow size.
//D6 - If 0, eyes will spawn at start. if 1, more eyes will be added as HP is reduced.

	

		npc PatraCore;
		npc PatraEye;
		int AimX1;
		int AimY1;
		int AimX2;
		int AimY2;
		int AimX3;
		int AimY3;
		int AimX4;
		int AimY4;



		while(true)
		{
			Waitframe();
			{

				if (!PatraCore->isValid()) PatraCore = LoadNPCOf(WhatID);
				else
				{
					Quit(); // Unfinished script
				}

			}
		}
	}
}

// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
// FFC script: Crazy Patras (end)
// --------------------------------------------------------------------------
// --------------------------------------------------------------------------







// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
// FFC script: Pouncing Gohma (start)
// --------------------------------------------------------------------------
// --------------------------------------------------------------------------

ffc script PouncingGohma
{
	void run(int WhatID, int GohmaWeakness, int SpecialWeapon)
	{
//D0 - ID of monster to operate.
//D1 - EWeapon ID Ghoma is weak to; used for toggling a specific script weapon defense.
//D2 - If 0, weapon will be EW_FIREBALL2 (boss fireball). Otherwise, D2 weapon will be used.
	

		npc ItsaGohma;
		int GohmaWait = 60;
		int FireballWait = 32;
		eweapon GohmaFire;
		lweapon FFCrandoLW;
		int FFCForTimer;

		while(true)
		{
			Waitframe();
			{
	
				if (!ItsaGohma->isValid()) ItsaGohma = LoadNPCOf(WhatID);
				else
				{
					if (ItsaGohma->Extend < 3)
					{
						ItsaGohma->Y = -72;
						ItsaGohma->TileWidth = 3;
						ItsaGohma->HitWidth = 48;
						ItsaGohma->DrawXOffset = -16;
						ItsaGohma->HitXOffset = -16;
						ItsaGohma->Extend = 3;
					}
					else if (ItsaGohma->HP > 0)
					{
				// Gohma moves
						Screen->Line(1,			//layer
								ItsaGohma->X+8,	//X1
								ItsaGohma->Y,	//Y2
								ItsaGohma->X+8,	//X2
								-58,		//Y2
								1,		//Color		
								1,		//Scale
								0,		//rx
								0,		//ry
								0,		//rangle
								128);		//opacity
						
						if (GohmaWait == 0)
						{
							if (ItsaGohma->Y == -72) ItsaGohma->X = Choose(48,96,144,192);
							if (ItsaGohma->Y < 128) ItsaGohma->Y = ItsaGohma->Y + 2;
							else GohmaWait = 60;
						}
						else
						{
							if (ItsaGohma->Y > -72) ItsaGohma->Y --;
							else GohmaWait --;
						}


				// Gohma attacks
						if (ItsaGohma->Y > 32)
						{
							if (FireballWait > 0) FireballWait --;
							else
							{
								if (SpecialWeapon == 0) GohmaFire = CreateEWeaponAt(EW_FIREBALL2,ItsaGohma->X,ItsaGohma->Y);
								else GohmaFire = CreateEWeaponAt(SpecialWeapon,ItsaGohma->X,ItsaGohma->Y);

								if (GohmaFire->X < Link->X) GohmaFire->Dir = DIR_RIGHT;
								else GohmaFire->Dir = DIR_LEFT;
								GohmaFire->Damage = ItsaGohma->WeaponDamage;
								if (GohmaFire->ID > EW_SCRIPT10)
								{
									if (GohmaFire->Angular == false)
									{
										GohmaFire->Angular = true;
										GohmaFire->Angle = RadianAngle(ItsaGohma->X,ItsaGohma->Y,Link->X,Link->Y);
									}
								}
								FireballWait = 32;
							}
						}


				// Special Gohma defenses
						for(FFCForTimer = Screen->NumLWeapons(); FFCForTimer > 0; FFCForTimer--)
						{
							FFCrandoLW = Screen->LoadLWeapon(FFCForTimer);
							if(!FFCrandoLW->isValid()) continue;
							{
								if (FFCrandoLW->ID == GohmaWeakness)
								{
									// Vulnerability to specific script weapon types
									if (GohmaWeakness >= LW_SCRIPT1)
									{
										if (ItsaGohma->Defense[NPCD_SCRIPT] != NPCDT_IGNORE1) ItsaGohma->Defense[NPCD_SCRIPT] = NPCDT_IGNORE1;
									}
								}
								if (FFCrandoLW->X > ItsaGohma->X - 35 && FFCrandoLW->X < ItsaGohma->X + 35 && FFCrandoLW->Y > ItsaGohma->Y - 19 && FFCrandoLW->Y < ItsaGohma->Y+19)
								{
									if(FFCrandoLW->X > ItsaGohma->X+14 || FFCrandoLW->X < ItsaGohma->X-14 || FFCrandoLW->Y < ItsaGohma->Y-4)
									{
										Remove(FFCrandoLW);
										Game->PlaySound(SFX_CLINK);
									}
								}
							}
						}
						if (ItsaGohma->Defense[NPCD_SCRIPT] == NPCDT_IGNORE1)
						{
							if (NumLWeaponsOf(GohmaWeakness) == 0) ItsaGohma->Defense[NPCD_SCRIPT] = NPCDT_BLOCK;
						}
	
					}
				}

			}
		}
	}
}


// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
// FFC script: Pouncing Gohma (end)
// --------------------------------------------------------------------------
// --------------------------------------------------------------------------





// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
// FFC script: Wraparound Aquamentus (start)
// --------------------------------------------------------------------------
// --------------------------------------------------------------------------


ffc script WraparoundAquamentus
{
	void run(int AquamentusID, int AquamentusTile, int UpShots, int DownShots, int DoesNotReturn, int AquamentusWeapon, int WeaponSpace)
	{

//D0 - NPC ID to spawn to be a wraparound Aquamentus.
//D1 - Original tile of Aquamentus enemy. Is designed for two-frame animation with 2x2 tiles, two left and two right, then a second row for the firing animation.
//D2 - How many fireballs to shoot upwards. (The center fireball is always fired regarldess of these numbers.)
//D3 - How many fireballs to shoot downwards.
//D4 - If 1, defeating this Aquamentus will set Screen->State[ST_ENEMYNORETURN] to true, to prevent the Aquamentus from spawning.
	//However, if this screen is the Dungeon Boss,  the Aquamentus won't return anyway.
//D5 - Set for a custom weapon. If 0, shoots EW_FIREBALL2.
//D6 - Increases gap between weapons when firing.


		this->Flags[FFCF_ETHEREAL] = true;
		npc WrapAqua;
		bool MakeAqua = true;
		if (Screen->State[ST_ENEMYNORETURN] || (Game->LItems[Game->GetCurLevel()] & LI_BOSS) != 0 && ScreenEFlag(SEF_LIST1, 3) > 0) MakeAqua = false;
		if (MakeAqua) WrapAqua = CreateNPCAt(AquamentusID,this->X,this->Y);
		else Quit();
		WrapAqua->Extend = 3;
		WrapAqua->TileHeight = 2;
		WrapAqua->TileWidth = 2;
		WrapAqua->HitXOffset = 8;
		WrapAqua->X = -48;

		int AquaWeapon;
		if (AquamentusWeapon > 0) AquaWeapon = AquamentusWeapon;
		else AquaWeapon = EW_FIREBALL2;

		eweapon Fireball1;
		eweapon Fireball2;
		eweapon Fireball3;
		int AquaTimer = 120;
		int ForTimer;
		int AquaWait;

		while(true)
		{
			Waitframe();
			{


				if (WrapAqua->X  < 112)
				{
					if (WrapAqua->Dir != DIR_RIGHT)
					{
						WrapAqua->Dir = DIR_RIGHT;
						if (WrapAqua->X < 0) WrapAqua->OriginalTile = AquamentusTile+4;
					}
				}
				else
				{
					if (WrapAqua->Dir != DIR_LEFT)
					{
						WrapAqua->Dir = DIR_LEFT;
						if (WrapAqua->X > 255) WrapAqua->OriginalTile = AquamentusTile;
					}
				}

				if (AquaTimer > 0)
				{
					if (WrapAqua->X  < -32 || WrapAqua->X >  256)
					{ 
						WrapAqua->Y = Choose(32,64,80,96);
						WrapAqua->X = Choose(-48,272);
						AquaTimer --;
					}
					else
					{
						if (WrapAqua->X < 112 && AquaWait < 4 && WrapAqua->HP >0) WrapAqua->X --;
						else if (AquaWait < 4 && WrapAqua->HP > 0) WrapAqua->X ++;
					}
				}
				else
				{
					if (WrapAqua->X < 56 && WrapAqua->HP > 0) WrapAqua->X ++;
					else if (WrapAqua->X > 184 && WrapAqua->HP > 0) WrapAqua->X --;
					else
					{
						if (WrapAqua->X == 56)
						{
							if (AquaWait == 0)
							{
								WrapAqua->OriginalTile = AquamentusTile + 44;
								Game->PlaySound(SFX_ROAR);

								eweapon Aquaball = CreateEWeaponAt(AquaWeapon,WrapAqua->X+8,WrapAqua->Y);
								Aquaball->Dir = DIR_RIGHT;
								Aquaball->Angular = true;
								Aquaball->Angle = RadianAngle(WrapAqua->X+16,WrapAqua->Y,Link->X,Link->Y);
	
								for(ForTimer = UpShots; ForTimer > 0; ForTimer--)
								{
									eweapon UpBall = CreateEWeaponAt(AquaWeapon,WrapAqua->X+8,WrapAqua->Y - (WeaponSpace+6)*ForTimer);
									UpBall->Damage = WrapAqua->WeaponDamage;
									UpBall->Dir = DIR_RIGHT;
									UpBall->Angular = true;
									UpBall->Angle = RadianAngle(UpBall->X,UpBall->Y,Link->X,Link->Y-32*ForTimer);	
								}
								for(ForTimer = DownShots; ForTimer > 0; ForTimer--)
								{
									eweapon UpBall = CreateEWeaponAt(AquaWeapon,WrapAqua->X+8,WrapAqua->Y + (WeaponSpace+6)*ForTimer);
									UpBall->Damage = WrapAqua->WeaponDamage;
									UpBall->Dir = DIR_RIGHT;
									UpBall->Angular = true;
									UpBall->Angle = RadianAngle(UpBall->X,UpBall->Y,Link->X,Link->Y+32*ForTimer);	
								}
	
								AquaTimer = Rand(16,80);
								AquaWait = 64;
							}
						}
						if (WrapAqua->X == 184)
						{
							if (AquaWait == 0)
							{
								WrapAqua->OriginalTile = AquamentusTile + 40;
								Game->PlaySound(SFX_ROAR);
	
								eweapon Aquaball = CreateEWeaponAt(AquaWeapon,WrapAqua->X+8,WrapAqua->Y);
								Aquaball->Dir = DIR_LEFT;
								Aquaball->Angular = true;
								Aquaball->Angle = RadianAngle(WrapAqua->X+8,WrapAqua->Y,Link->X+8,Link->Y);

								for(ForTimer = UpShots; ForTimer > 0; ForTimer--)
								{
									eweapon UpBall = CreateEWeaponAt(AquaWeapon,WrapAqua->X+8,WrapAqua->Y - (WeaponSpace+6)*ForTimer);
									UpBall->Damage = WrapAqua->WeaponDamage;
									UpBall->Dir = DIR_LEFT;
									UpBall->Angular = true;
									UpBall->Angle = RadianAngle(UpBall->X,UpBall->Y,Link->X,Link->Y-32*ForTimer);	
								}
								for(ForTimer = DownShots; ForTimer > 0; ForTimer--)
								{
									eweapon UpBall = CreateEWeaponAt(AquaWeapon,WrapAqua->X+8,WrapAqua->Y + (WeaponSpace+6)*ForTimer);
									UpBall->Damage = WrapAqua->WeaponDamage;
									UpBall->Dir = DIR_LEFT;
									UpBall->Angular = true;
									UpBall->Angle = RadianAngle(UpBall->X,UpBall->Y,Link->X,Link->Y+32*ForTimer);	
								}

								AquaTimer = Rand(16,80);
								AquaWait = 64;
							}
						}
					}
				}
				if (AquaWait > 0) AquaWait --;
				if (AquaWait == 16)
				{
					if (WrapAqua->Dir == DIR_LEFT) WrapAqua->OriginalTile = AquamentusTile;
					else WrapAqua->OriginalTile = AquamentusTile+4;
				}

				if (WrapAqua->HP <= 0)
				{
					if (DoesNotReturn != 0 && !Screen->State[ST_ENEMYNORETURN]) Screen->State[ST_ENEMYNORETURN] = true; 
				}

			}		
		}	
		
	}
}

// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
// FFC script: Wraparound Aquamentus (end)
// --------------------------------------------------------------------------
// --------------------------------------------------------------------------



// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
// FFC script: Growing Manhandla (start)
// --------------------------------------------------------------------------
// --------------------------------------------------------------------------


ffc script GrowingManhandla
{
	void run(int Manhandla_Core_ID, int Manhandla_Heads_ID, int Head_Starting_Tile, int NoGrow, int StepMultiplier, int NoHeadOffset)
	{

//See the global script for a list of the constants used in array ManOffset[].

//D0 - ID of the core NPC. Spawned by this script. This NPC should determine the movement type (I used an NPCT_PATRA enemy because their ->Step can be adjusted).
//D1 - ID of the heads. Spawned by this script.
//D2 - Upper left starting Tile of block of head tiles. 
	//Appropriate head/neck tiles are then offset according to a set of variables in the array "ManOffset[]".
	//It's currently set up for the following tile layout:
	//
	//U1 U2 L1 L2 HN HN R1 HN HN R2 
	//VN VN L1 HN L2 HN HN R1 HN R2
	//VN VN L1 HN HN L2 HN HN R1 R2
	//D1 D2
	//
	//U  = Up head;
	//D  = Down head;
	//L  = Left head;
	//R  = Right head;
	// 1 = Open mouth;
	// 2 = Closed mouth;
	//CN = Center;
	//VN = Vertical Neck;
	//HN = Horizontal Neck
//D3 -	Changes growth:
	//If 0, Manhandla grows as it takes damage.
	//If 1, Manhandla is normal size and never grows. 
	//If 2, Manhandla starts at two tile length and will not grow.
	//If 3, Mahandla starts at three tile length and will not grow.
//D4 - Amount by which the Manhandla core's step will be multiplied when heads are lost. Set to 1 for no increase; 0 will default to 1.5.
//D5 - Set to non-0 to prevent any animation changes to the first form of the heads.


		this->Flags[FFCF_ETHEREAL] = true;


		int ManOffset[10];
		ManOffset[HEAD_LEFT_A] = Head_Starting_Tile +	 2;
		ManOffset[HEAD_RIGHT_C] = Head_Starting_Tile +	 4;
		ManOffset[HEAD_DOWN_C] = Head_Starting_Tile +	 20;
		ManOffset[HEAD_LEFT_B] = Head_Starting_Tile +	 22;
		ManOffset[HEAD_RIGHT_B] = Head_Starting_Tile +	 26;
		ManOffset[HEAD_DOWN_B] = Head_Starting_Tile +	 40;
		ManOffset[HEAD_LEFT_C] = Head_Starting_Tile +	 42;
		ManOffset[HEAD_RIGHT_A] = Head_Starting_Tile +	 48;
		ManOffset[HEAD_DOWN_A] = Head_Starting_Tile +	 60;
	
		Waitframes(4);
	
		npc HeadUp;
		npc HeadDown;
		npc HeadLeft;
		npc HeadRight;	
	
		npc ManCore = LoadNPCOf(Manhandla_Core_ID); 
		if (ManCore->isValid())
		{
			HeadUp = CreateNPCAt(Manhandla_Heads_ID,ManCore->X,ManCore->Y); 
			HeadDown = CreateNPCAt(Manhandla_Heads_ID,ManCore->X,ManCore->Y);
			HeadLeft = CreateNPCAt(Manhandla_Heads_ID,ManCore->X,ManCore->Y);
			HeadRight = CreateNPCAt(Manhandla_Heads_ID,ManCore->X,ManCore->Y);	
			ManCore->CollDetection = 0;
		}



		int ManStartHP = HeadUp->HP;
		int ManCoreStartStep = ManCore->Step;
		int ManBoostStep[6];
		ManBoostStep[1] = 1;
		ManBoostStep[2] = 1;
		ManBoostStep[3] = 1;
		ManBoostStep[4] = 1;
	
		if (NoHeadOffset == 0)
		{
			HeadDown->OriginalTile = ManOffset[HEAD_DOWN_A];
			HeadLeft->OriginalTile = ManOffset[HEAD_LEFT_A];
			HeadRight->OriginalTile = ManOffset[HEAD_RIGHT_A];	
		}
		ManCore->DrawYOffset = 255;





// Start at 2 tiles
		if (NoGrow == 2)
		{
			// Head Up
			if (HeadUp->isValid())
			{
				HeadUp->Extend = 3;
				HeadUp->DrawYOffset = -16;
				HeadUp->HitYOffset = -16;
				HeadUp->HitHeight = 32;
				HeadUp->TileHeight = 2;
			}
			// Head Down
			if (HeadDown->isValid())
			{
				HeadDown->Extend = 3;
				HeadDown->HitHeight = 32;
				HeadDown->OriginalTile = ManOffset[HEAD_DOWN_B];
				HeadDown->TileHeight = 2;
			}
			// Head Left
			if (HeadRight->isValid())
			{
				HeadLeft->Extend = 3;
				HeadLeft->HitXOffset = -16;
				HeadLeft->DrawXOffset = -16;
				HeadLeft->HitWidth = 32;
				HeadLeft->OriginalTile = ManOffset[HEAD_LEFT_B];
				HeadLeft->TileWidth = 2;
			}
			// Head Right
			if (HeadRight->isValid())
			{
				HeadRight->Extend = 3;
				HeadRight->HitWidth = 32;
				HeadRight->OriginalTile = ManOffset[HEAD_RIGHT_B];
				HeadRight->TileWidth = 2;
			}
		}


// Start at 3 tiles
		if (NoGrow == 3)
		{
			// Head Up
			if (HeadUp->isValid())
			{
				HeadUp->Extend = 3;
				HeadUp->DrawYOffset = -32;	
				HeadUp->HitYOffset = -32;
				HeadUp->HitHeight = 48;
				HeadUp->TileHeight = 3;
			}
			// Head Down
			if (HeadDown->isValid())
			{
				HeadDown->Extend = 3;
				HeadDown->HitHeight = 48;
				HeadDown->OriginalTile = ManOffset[HEAD_DOWN_C];
				HeadDown->TileHeight = 3;
			}
			// Head Left
			if (HeadRight->isValid())
			{
				HeadLeft->Extend = 3;
				HeadLeft->HitXOffset = -32;
				HeadLeft->DrawXOffset = -32;
				HeadLeft->HitWidth = 48;
				HeadLeft->OriginalTile = ManOffset[HEAD_LEFT_C];
				HeadLeft->TileWidth = 3;
			}
			// Head Right
			if (HeadRight->isValid())
			{
				HeadRight->Extend = 3;
				HeadRight->HitWidth = 48;
				HeadRight->OriginalTile = ManOffset[HEAD_RIGHT_C];
				HeadRight->TileWidth = 3;
			}
		}






		while(true)
		{
			Waitframe();
			{
				if (ManCore->isValid())
				{


// Heads stick to core
					HeadUp->X = ManCore->X;
					HeadUp->Y = ManCore->Y-16;
					HeadUp->Dir = DIR_UP;
					HeadDown->X = ManCore->X;
					HeadDown->Y = ManCore->Y+16;
					HeadDown->Dir = DIR_DOWN;
					HeadLeft->X = ManCore->X-16;
					HeadLeft->Y = ManCore->Y;
					HeadLeft->Dir = DIR_LEFT;
					HeadRight->X = ManCore->X+16;
					HeadRight->Y = ManCore->Y;
					HeadRight->Dir = DIR_RIGHT;

					if (ManCore->DrawYOffset > 0) Screen->FastTile(3,ManCore->X,ManCore->Y-2,ManCore->Tile,ManCore->CSet,128);

// Speeds up when heads are lost
					if (ManCore->Step < ManCoreStartStep * ManBoostStep[1] * ManBoostStep[2]  * ManBoostStep[3]  * ManBoostStep[4])		ManCore->Step = ManCoreStartStep * ManBoostStep[1] * ManBoostStep[2]  * ManBoostStep[3]  * ManBoostStep[4];


// Head Up
					if (HeadUp->isValid())
					{
						if (NoGrow == 0)
						{
							if (HeadUp->TileHeight < 2)
							{
								if (HeadUp->HP < (ManStartHP / 3) * 2){
									ManCore->Stun = 32;
									HeadUp->Stun = 96;
									HeadUp->Extend = 3;
									HeadUp->DrawYOffset = -16;
									HeadUp->HitYOffset = -16;
									HeadUp->HitHeight = 32;
									HeadUp->TileHeight = 2;
								}
							}
		 					if (HeadUp->TileHeight < 3)
							{
								if (HeadUp->HP < (ManStartHP / 3)){
									ManCore->Stun = 32;
									HeadUp->Stun = 96;
									HeadUp->DrawYOffset = -32;	
									HeadUp->HitYOffset = -32;
									HeadUp->HitHeight = 48;
									HeadUp->TileHeight = 3;
								}
							}
						} 
					}
					else if (ManBoostStep[1] != StepMultiplier)
					{
						if (StepMultiplier != 0) ManBoostStep[1] = StepMultiplier;
						else ManBoostStep[1] = 1.5;
					}


// Head Down
					if (HeadDown->isValid())
					{
						if (NoGrow == 0)
						{
							if (HeadDown->TileHeight < 2)
							{
								if (HeadDown->HP < (ManStartHP / 3) * 2){
									ManCore->Stun = 32;
									HeadDown->Stun = 96;
									HeadDown->Extend = 3;
									HeadDown->HitHeight = 32;
									HeadDown->OriginalTile = ManOffset[HEAD_DOWN_B];
									HeadDown->TileHeight = 2;
								}
							} 
							if (HeadDown->TileHeight < 3)
							{
									if (HeadDown->HP < (ManStartHP / 3)){
									ManCore->Stun = 32;
									HeadDown->Stun = 96;
									HeadDown->HitHeight = 48;
									HeadDown->OriginalTile = ManOffset[HEAD_DOWN_C];
									HeadDown->TileHeight = 3;
								}
							} 
						}
					}
					else if (ManBoostStep[2] != StepMultiplier)
					{
						if (StepMultiplier != 0) ManBoostStep[2] = StepMultiplier;
						else ManBoostStep[2] = 1.5;
					}

// Head Left
					if (HeadLeft->isValid())
					{
						if (NoGrow == 0)
						{
							if (HeadLeft->TileWidth < 2)
							{
								if (HeadLeft->HP < (ManStartHP / 3) * 2){
									ManCore->Stun = 32;
									HeadLeft->Stun = 96;
									HeadLeft->Extend = 3;
									HeadLeft->HitXOffset = -16;
									HeadLeft->DrawXOffset = -16;
									HeadLeft->HitWidth = 32;
									HeadLeft->OriginalTile = ManOffset[HEAD_LEFT_B];
									HeadLeft->TileWidth = 2;
								}
							} 
							if (HeadLeft->TileWidth < 3)
							{
								if (HeadLeft->HP < (ManStartHP / 3)){
									ManCore->Stun = 32;
									HeadLeft->Stun = 96;
									HeadLeft->HitXOffset = -32;
									HeadLeft->DrawXOffset = -32;
									HeadLeft->HitWidth = 48;
									HeadLeft->OriginalTile = ManOffset[HEAD_LEFT_C];
									HeadLeft->TileWidth = 3;
								}
							}
						}
					} 
					else if (ManBoostStep[3] != StepMultiplier)
					{
						if (StepMultiplier != 0) ManBoostStep[3] = StepMultiplier;
						else ManBoostStep[1] = 1.5;
					}


// Head Right
					if (HeadRight->isValid())
					{
						if (NoGrow == 0)
						{
							if (HeadRight->TileWidth < 2)
							{
								if (HeadRight->HP < (ManStartHP / 3) * 2){
									ManCore->Stun = 32;
									HeadRight->Stun = 96;
									HeadRight->Extend = 3;
									HeadRight->HitWidth = 32;
									HeadRight->OriginalTile = ManOffset[HEAD_RIGHT_B];
									HeadRight->TileWidth = 2;
								}
							} 
							if (HeadRight->TileWidth < 3)
							{
								if (HeadRight->HP < (ManStartHP / 3)){
									ManCore->Stun = 32;
									HeadRight->Stun = 96;
									HeadRight->HitWidth = 48;
									HeadRight->OriginalTile = ManOffset[HEAD_RIGHT_C];
									HeadRight->TileWidth = 3;
								}	
							}
						} 
					}
					else if (ManBoostStep[4] != StepMultiplier)
					{
						if (StepMultiplier != 0) ManBoostStep[4] = StepMultiplier;
						else ManBoostStep[1] = 1.5;
					}

// All heads defeated
					if (!HeadUp->isValid() && !HeadDown->isValid() && !HeadLeft->isValid() && !HeadRight->isValid())
					{
						if (ManCore->DrawYOffset > 0) ManCore->DrawYOffset = 0;
						ManCore->HP = 0;
						Quit();
					}

				}
			}
		}
	}
}

// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
// FFC script: Growing Manhandla (start)
// --------------------------------------------------------------------------
// --------------------------------------------------------------------------









// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
// FFC script: Moldorm behavior / Lanmola behavior (start)
// --------------------------------------------------------------------------
// --------------------------------------------------------------------------


ffc script MoldormBehavior
{
	void run(int HeadID, int SegmentID, int SegmentsToMake, int SegmentLag, int InvincibleHead)
	{

//D0 - ID of NPC to use as the head
//D1 - ID of NPC to use as the segment
//D2 - Number of segments to create
//D3 - Segment lag
//D4 - if 0, Head cannot be killed until segments are killed. If 1, Segments will die when head dies. For any other value, all segments remain after head dies.


		this->Flags[FFCF_ETHEREAL] = true;

		int ForTimer;
		int ArrayX[1024];
		int ArrayY[1024];
		npc Segment;



		Waitframes(4);

		npc Head = LoadNPCOf(HeadID);	
		int HeadStartHP = Head->HP;

		if (Head->isValid())
		{
			for(ForTimer = SegmentsToMake; ForTimer > 0; ForTimer--)
			{
				npc NewSegment = CreateNPCAt(SegmentID,Head->X,Head->Y);
			}
		}
		else Quit();

		for(ForTimer = 1024; ForTimer > 0; ForTimer--)
		{
			ArrayX[ForTimer] = Head->X;
			ArrayY[ForTimer] = Head->Y;
		}


		while(true)
		{
			Waitframe();
			{			


	// --- Head can't be killed until segments are killed

				if (InvincibleHead == 0)
				{
					if (Head->HP < HeadStartHP)
					{
						if (NumNPCsOf(SegmentID) > 0) Head->HP = HeadStartHP;
					}
				}



	// --- Or, segments all die if head dies
				else if (InvincibleHead == 1)
				{
					if (Head->HP <= 0)
					{
						for(ForTimer = Screen->NumNPCs(); ForTimer > 0; ForTimer--)
						{
							Segment = Screen->LoadNPC(ForTimer);
							if(!Segment->isValid()) continue;
							{
								if (Segment->ID == SegmentID)
								{
									Segment->HP = 0;
								}
							}
						}

					}
				}


	// --- Moldorm movement

				if (Head->HP > 0)
				{
					ArrayX[0] = Head->X;
					ArrayY[0] = Head->Y;
				}

				for(ForTimer = 1024; ForTimer > 0; ForTimer--)
				{
					if (ForTimer > 0) ArrayX[ForTimer] = ArrayX[ForTimer-1];
					if (ForTimer > 0) ArrayY[ForTimer] = ArrayY[ForTimer-1];
				}


				for(ForTimer = Screen->NumNPCs(); ForTimer > 0; ForTimer--)
				{
					Segment = Screen->LoadNPC(ForTimer);
					if(!Segment->isValid()) continue;
					{
						if (Segment->ID == SegmentID)
						{

							if (Segment->Y > ArrayY[(ForTimer-1)*SegmentLag]) Segment->Dir = DIR_UP;
							if (Segment->Y < ArrayY[(ForTimer-1)*SegmentLag]) Segment->Dir = DIR_DOWN;
							if (Segment->X > ArrayX[(ForTimer-1)*SegmentLag]) Segment->Dir = DIR_LEFT;
							if (Segment->X < ArrayX[(ForTimer-1)*SegmentLag]) Segment->Dir = DIR_RIGHT;

							if (ArrayX[(ForTimer-1)*SegmentLag] > 0) Segment->X = ArrayX[(ForTimer-1)*SegmentLag];
							if (ArrayY[(ForTimer-1)*SegmentLag] > 0) Segment->Y = ArrayY[(ForTimer-1)*SegmentLag];
						}
					}
				}

			}
		}
	}
}




// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
// FFC script: Moldorm behavior / Lanmola behavior (end)
// --------------------------------------------------------------------------
// --------------------------------------------------------------------------






// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
// FFC script: Moldorm Growing / Lanmola Growing (start)
// --------------------------------------------------------------------------
// --------------------------------------------------------------------------


ffc script MoldormGrowing
{
	void run(int HeadID, int SegmentID, int SegmentRate, int SegmentLag)
	{

//D0 - ID of NPC to use as the head
//D1 - ID of NPC to use as the segment
//D2 - How many HP must be lost to grow a new segment. 
	// This enemy is balanced better with fairly high HP because the segments tend to get spammed with damage by Link easily.
	// Therefore, it's important to set a SegmentRate that makes enough segments to be fair for the intended context.
//D3 - Segment lag



		this->Flags[FFCF_ETHEREAL] = true;


		int ForTimer;
		int ArrayX[511];
		int ArrayY[511];
		int HPSyncWait;
		npc Segment;
		npc NewSegment;

		Waitframes(4);

		npc Head = LoadNPCOf(HeadID);	
		int HeadStartHP = Head->HP;

		if (!Head->isValid()) Quit();

		for(ForTimer = 511; ForTimer > 0; ForTimer--)
		{
			ArrayX[ForTimer] = Head->X;
			ArrayY[ForTimer] = Head->Y;
		}



		while(true)
		{
			Waitframe();
			{			

				if (Head->isValid())
				{


					if (Head->HP > 0)
					{
						if (NumNPCsOf(SegmentID) < (HeadStartHP - Head->HP)/SegmentRate)
						{
							NewSegment = CreateNPCAt(SegmentID,Head->X,Head->Y);
							NewSegment->HP = Head->HP;
							NewSegment->CollDetection = 0;
							NewSegment->Stun = 120;
						}

						ArrayX[0] = Head->X;
						ArrayY[0] = Head->Y;	
					}
	
					for(ForTimer = 255; ForTimer > 0; ForTimer--)
					{
						if (ForTimer > 0) ArrayX[ForTimer] = ArrayX[ForTimer-1];
						if (ForTimer > 0) ArrayY[ForTimer] = ArrayY[ForTimer-1];
					}

	

					if (HPSyncWait > 0) HPSyncWait --;


					for(ForTimer = Screen->NumNPCs(); ForTimer > 0; ForTimer--)
					{
						Segment = Screen->LoadNPC(ForTimer);
						if(!Segment->isValid()) continue;
						{
							if (Segment->ID == SegmentID)
							{
								if (Segment->Y > ArrayY[(ForTimer-1)*SegmentLag]) Segment->Dir = DIR_UP;
								if (Segment->Y < ArrayY[(ForTimer-1)*SegmentLag]) Segment->Dir = DIR_DOWN;
								if (Segment->X > ArrayX[(ForTimer-1)*SegmentLag]) Segment->Dir = DIR_LEFT;
								if (Segment->X < ArrayX[(ForTimer-1)*SegmentLag]) Segment->Dir = DIR_RIGHT;

								if (ArrayX[(ForTimer-1)*SegmentLag] > 0) Segment->X = ArrayX[(ForTimer-1)*SegmentLag];
								if (ArrayY[(ForTimer-1)*SegmentLag] > 0) Segment->Y = ArrayY[(ForTimer-1)*SegmentLag];

								if (Segment->Stun == 0 && Segment->CollDetection == 0) Segment->CollDetection = 1;

								if (Head->HP > Segment->HP) Head->HP = Segment->HP;
								if (Segment->HP > Head->HP) Segment->HP = Head->HP;

							}
						}
					}
				}

			}
		}
	}
}






// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
// FFC script: Growing Moldorm / Growing Lanmola (end)
// --------------------------------------------------------------------------
// --------------------------------------------------------------------------





// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
// FFC script: NPC Following Segments offkilter (start)
// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
// NOTE: This is an early failed attempt at the Moldorm behavior script. I may ditch this one.



ffc script NPCFollowingSegmentsOffkilter
{
	void run(int WhatID, int NewSegmentID, int HowManyToAdd, int SegmentLag)
	{


		this->Flags[FFCF_ETHEREAL] = true;


		int FFCForTimer;
		npc FFCrandoNPC;

		Waitframes(4);
		npc Segment1 = LoadNPCOf(WhatID);
		int Segment1StartHP = Segment1->HP;

		while(true)
		{
			Waitframe();


			if (Segment1->isValid())
			{
				if (Segment1->HP <= 4)
				{
					if (NumNPCsOf(NewSegmentID) < HowManyToAdd)
					{
						npc Segment2 = CreateNPCAt(NewSegmentID,Segment1->X,Segment1->Y);
						if (Segment2->isValid()) Segment2->Stun = SegmentLag;	
						Segment1->HP = Segment1StartHP;
					}
				}
			}



			for(FFCForTimer = Screen->NumNPCs(); FFCForTimer > 0; FFCForTimer--)
			{
				FFCrandoNPC = Screen->LoadNPC(FFCForTimer);
				if(FFCrandoNPC->ID == NewSegmentID)
				{
					if (Segment1->HP > FFCrandoNPC->HP) Segment1->HP = FFCrandoNPC->HP;
					else FFCrandoNPC->HP = Segment1->HP;
					if (FFCrandoNPC->HP <= 4) FFCrandoNPC->HP = Segment1StartHP;
					if (FFCrandoNPC->Stun == 1)
					{
						FFCrandoNPC->Misc[7] = Segment1->X;
						FFCrandoNPC->Misc[8] = Segment1->Y;
					}
					if (FFCrandoNPC->Stun == 0)
					{
						if (FFCrandoNPC->X < FFCrandoNPC->Misc[7]) FFCrandoNPC->X ++;
						if (FFCrandoNPC->X > FFCrandoNPC->Misc[7]) FFCrandoNPC->X --;
						if (FFCrandoNPC->Y < FFCrandoNPC->Misc[8]) FFCrandoNPC->Y ++;
						if (FFCrandoNPC->Y > FFCrandoNPC->Misc[8]) FFCrandoNPC->Y --;
					}
					if (FFCrandoNPC->X == FFCrandoNPC->Misc[7] && FFCrandoNPC->Y == FFCrandoNPC->Misc[8])
					{
						FFCrandoNPC->Stun = SegmentLag;
						FFCrandoNPC->Misc[7] = Segment1->X;
						FFCrandoNPC->Misc[8] = Segment1->Y;
					}
					if (FFCrandoNPC->X == Segment1->X &&FFCrandoNPC->Y == Segment1->Y) FFCrandoNPC->Stun = SegmentLag;
					if (!Segment1->isValid()) FFCrandoNPC->HP = 0;
				}
			}
		}
	}
}


// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
// FFC script: NPC Following Segments offkilter (end)
// --------------------------------------------------------------------------
// --------------------------------------------------------------------------




// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
// FFC script: Specific Script Defense (start)
// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
// This is a workaround to there only being one Script Weapon defense in the editor in pre-2.55 versions.
// There's probably better ways to do this, even until then, but I figured it works for now.


ffc script SpecificLWDefense
{
	void run(int WhatEnemyID, int WhatLWeapon, int IgnoreWeapon)
	{

//D0 - NPC ID to affect
//D1 - 1 = LW_SCRIPT1; 9 = LW_SCRIPT9; etc. If the number is >10 then it will count the actual weapon ID. A 0 script damage weapon still won't work.
//D2 - If 0, NPC will block wrong script weaopns. Otherwise, NPC will ignore wrong script weapons.

		int ID_Offset;
		if (WhatLWeapon < 11) ID_Offset = 30;
		npc FFCrandoNPC;
		lweapon FFCrandoLW;
		int FFCForTimer;

		while(true)
		{
			Waitframe();
			
			for(FFCForTimer = Screen->NumNPCs(); FFCForTimer > 0; FFCForTimer--)
			{
				FFCrandoNPC = Screen->LoadNPC(FFCForTimer);
				if(!FFCrandoNPC->isValid()) continue;
				{
					if (FFCrandoNPC->ID == WhatEnemyID)
					{
						if (FFCrandoNPC->Defense[NPCD_SCRIPT] != NPCDT_IGNORE1)
						{
							for(FFCForTimer = Screen->NumLWeapons(); FFCForTimer > 0; FFCForTimer--)
							{
								FFCrandoLW = Screen->LoadLWeapon(FFCForTimer);
								if(!FFCrandoLW->isValid()) continue;
								if (FFCrandoLW->ID == WhatLWeapon + ID_Offset)
								{
									FFCrandoNPC->Defense[NPCD_SCRIPT] = NPCDT_IGNORE1;
								}
							}
						}
						else if (NumLWeaponsOf(WhatLWeapon) == 0)
						{
								if (IgnoreWeapon == 0) FFCrandoNPC->Defense[NPCD_SCRIPT] = NPCDT_BLOCK;
								else FFCrandoNPC->Defense[NPCD_SCRIPT] = NPCDT_IGNORE;
						}
					}
				}
			}

		}
	}
}



// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
// FFC script: Specific Script Defense (end) 
// --------------------------------------------------------------------------
// --------------------------------------------------------------------------





// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
// FFC script: Falling Pushblock (start)
// --------------------------------------------------------------------------
// --------------------------------------------------------------------------

ffc script FallingPushblocks
{
	void run()
	{

	int FFCForTimer;
	lweapon SmashyFally;

	this->Flags[FFCF_ETHEREAL] = true;

		while(true)
		{
			Waitframe();

			if (SmashyFally->isValid()) Remove(SmashyFally);

			for (FFCForTimer = 176; FFCForTimer > 0; FFCForTimer--)
			{
				if (Screen->ComboF[FFCForTimer] >= CF_PUSHUPDOWN && Screen->ComboF[FFCForTimer] <= CF_PUSH4WAY || Screen->ComboF[FFCForTimer] >= CF_PUSHLR && Screen->ComboF[FFCForTimer] <= CF_PUSHRIGHTINS)
				{
					if (Screen->ComboI[FFCForTimer + 16] != CF_NOBLOCKS)
					{
						if (Screen->ComboF[FFCForTimer] + 16 != CF_NOBLOCKS)
						{
							if (Screen->ComboS[FFCForTimer + 16] == 0) 
							{
								Screen->ComboD[FFCForTimer + 16] = Screen->ComboD[FFCForTimer];
								Screen->ComboF[FFCForTimer + 16] = Screen->ComboF[FFCForTimer];
								Screen->ComboD[FFCForTimer] = Screen->UnderCombo;
								Screen->ComboF[FFCForTimer] = CF_NONE;
								SmashyFally = CreateLWeaponAt(LW_REFROCK,ComboX(FFCForTimer),ComboY(FFCForTimer+16));
								SmashyFally->Damage = 255;
								SmashyFally->DrawYOffset = 255;
								Game->PlaySound(SFX_SHUTTER);
							}
						}
					}
				}
			}
		}
	}
}
// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
// FFC script: Falling Pushblock (end)
// --------------------------------------------------------------------------
// --------------------------------------------------------------------------





// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
// FFC script: Big Armos (start)
// --------------------------------------------------------------------------
// --------------------------------------------------------------------------

//This FFC must be placed in the upper-left corner of a 2x2 space which it will uncover.

ffc script BigArmos
{
	void run(int ArmosSecrets, int NoItemRequired)
	{
//D0 - If 0, Screen->Undercombo will be left under this FFC. Otherwise, touching this armos will trigger temporary secrets.
//D1 - if 0, will require the item I_ARMOS to be in Link's inventory. Otherwise, no item is needed.

	this->Flags[FFCF_ETHEREAL] = true;
	this->TileWidth = 2;
	this->TileHeight = 2;
	int WaitToClear = 0;

		while(true)
		{
			Waitframe();
			
			if (Link->Item[I_ARMOS] || NoItemRequired != 0)
			{
				if (WaitToClear == 0)
				{
					if (LinkCollision(this))
					{
						Game->PlaySound(SFX_SHUTTER);
						WaitToClear = 200;
					}
				}
			}
			if (WaitToClear > 0)
			{
				WaitToClear --;
				if (WaitToClear > 60)
				{
					if(!(WaitToClear%2)) Screen->DrawTile(
							3,
							this->X,	//start X
							this->Y,	//start y
							BIGARMOS_TILE,	//tile ID
							2,		//tile width
							2,		//tile width
							7,		//tile cset
							-1,-1,-1,-1,0,0,1,128);
				}
				else if (WaitToClear == 60){
					Game->PlaySound(SFX_ROAR);
					npc BigArmos = CreateNPCAt(NPC_BIGARMOS,this->X+8,this->Y+8);
				}
				else if (WaitToClear == 1)
				{
					if (ArmosSecrets == 1)
					{
						Screen->TriggerSecrets();
						Game->PlaySound(SFX_SECRET);
					}
					else
					{
						Screen->ComboD[ComboAt(this->X+8,this->Y+8)] = Screen->UnderCombo; 
						Screen->ComboD[ComboAt(this->X+24,this->Y+8)] = Screen->UnderCombo;
						Screen->ComboD[ComboAt(this->X+8,this->Y+24)] = Screen->UnderCombo;
						Screen->ComboD[ComboAt(this->X+24,this->Y+24)] = Screen->UnderCombo;
					}
					Quit();
				}
			}
		}		
	}
}




// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
// FFC script: Fishing (start)
// --------------------------------------------------------------------------
// --------------------------------------------------------------------------

ffc script Fishing
{
	void run(int Warp, int MeterTile, int BonusPrize1, int BonusPrize2, int SplashSprite, int SetLocation)
	{

// D0: If set to something other than 0, this FFC will set it's combo data to D0 (as soon as it isn't touching Link), and not run the rest of the script.
// D1: Tile to use for drawing the cast-charging meter. 0 for no meter.
// D2: Bonus prize that has a chance of appearing after the screen item is obtained. Use this only for good.
	// Set D2 to a negative number to prevent any bonus prizes appearing after the screen item.
// D3: A second bonus prize like the first that has a slightly smaller chance of appearing. Seriously, don't use this for evil purposes or I will 1 star your quest on PureZC.
// D4: Weapon sprite to use for splash animation when hook hits the water (0 for no effect)
// D5: If greater than 0, bonus prizes will appear at Combo[D5]. If 0, bonus prizes will spawn at random non-solid locations.

		int RodCharge;
		int RodChargeWait;
		bool RodIsCast;
		bool ItemIsHooked;
		bool NoRepeatA;
		bool HasSplashed;
		bool PositionSet;
		int StopPrizes = Rand(2,16);
		int FirstItemX;
		int FirstItemY;

		item FFCRandoItem;
		item HookedItem;
		item BonusRupy;
		npc FFCRandoNPC;
		eweapon FFCRandoEW;
		int FFCForTimer;



		if (Warp > 0)
		{
			while(LinkCollision(this))	Waitframe();
			if (Link->Item[I_FISHINGROD]) this->Data = Warp;
		}
		else
		{
			DoDraw = false;
			this->X = Link->X-8;
			this->Y = Link->Y+8;
			while(true)
			{	

// ------------ Meter
				if (RodCharge > 5 && MeterTile != 0)
				{
					for(FFCForTimer = RodCharge-6; FFCForTimer > 0; FFCForTimer--)
					{
						Screen->FastTile(7,64+(FFCForTimer-1)*8,-8,MeterTile,this->CSet,128);		
					}
				}


				Waitframe();
				Link->Jump = 0;
				Link->X = 224;
				Link->Y = 16;
				Link->Dir = DIR_LEFT;

// ------------ Leave the screen
				if (Link->PressStart)
				{
					Link->X = 256;
					DoDraw = true;
				}


// ------------ Link animations during fishing
				if (Link->Action != LA_HOLD1LAND && Link->Action != LA_HOLD2LAND)
				{

					if (RodIsCast)
					{ 
						Link->Action = LA_NONE;
						Link->Action = LA_ATTACKING;
					}
				}
				else
				{
					this->X = Link->X-8;
					this->Y = Link->Y+8;
					RodIsCast = false;
				}


// ------------ Fishing hook trigger secrets
				if (Screen->ComboF[ComboAt(this->X+7,this->Y+8)] == CF_STRIKE && !Screen->State[ST_SECRET]){
					Screen->State[ST_SECRET] = true;
					Game->PlaySound(27);
					Screen->TriggerSecrets();
				}



// ------------ Controlling the fishing hook
				if (Link->PressA && !RodIsCast) NoRepeatA = true;


// ------------ Preparing to cast the hook
				if (Link->InputA)
				{
					if (LinkCollision(this) && !RodIsCast)
					{
						if (NoRepeatA)
						{
							if (Link->PressA) Game->PlaySound(SFX_ARROW);
							if (RodCharge == 0) RodCharge = 5;
							if (RodChargeWait == 0)
							{
								RodCharge ++;
								RodChargeWait = 4;
							}
							else if (RodCharge < 22) RodChargeWait --;
							Screen->FastTile(4,Link->X-10,Link->Y-2,FISHINGROD_TILE+2,this->CSet,128);
						}
					}
					else
					{
// ------------ Reeling in the hook
						if (this->Y < Link->Y+8) this->Y ++;
						if (this->Y > Link->Y+8)
						{
							if (Screen->ComboS[ComboAt(this->X+7,this->Y-1)] == 0 || this-> Y < Link->Y+32 && this->X > Link->X - 16) this->Y --;
						}

						if (this->X > Link->X-8) this->X --;
						if (this->X < Link->X-8)
						{
							if (Screen->ComboS[ComboAt(this->X+12,this->Y+8)] != 1111b || this-> Y < Link->Y+32 && this->X > Link->X - 16) this->X ++;
						}
						if (LinkCollision(this)){
							PositionSet = false;
							RodIsCast = false;
							this->X = Link->X-8;
							this->Y = Link->Y+8;
						}
						Screen->FastTile(4,Link->X-10,Link->Y-2,FISHINGROD_TILE+1,this->CSet,128);
					}
				}
				else
				{
// ------------ Casting the fishing hook
					if (RodCharge > 0){
						Game->PlaySound(SFX_BRANG);
						this->Vx = this->Vx - RodCharge;
						this->Vy = (RodCharge/2 - RodCharge);
						RodCharge = 0;
						RodIsCast = true;
					}
					Screen->FastTile(4,Link->X-10,Link->Y-2,FISHINGROD_TILE,this->CSet,128);
// ------------ The hook sinks
					if (!LinkCollision(this) && Screen->ComboS[ComboAt(this->X+7,this->Y+17)] != 1111b) this->Y ++;
				}

				if (!Link->PressA && !Link->InputA && NoRepeatA) NoRepeatA = false; 


// ------------ Casting momentum slows
				if (this->Vx != 0)
				{
//					if (Screen->ComboS[ComboAt(this->X+7,this->Y-2)] == 0 && this->Y > -8) this->Y = this->Y - 4; 
					if (this->Vx < 0) this->Vx ++;
					if (this->X <= 0 || this->Vx > 0) this->Vx = 0;
				}
				if (this->Vy != 0)
				{
					if (this->Vy < 0) this->Vy ++;
					if (this->Y <= -8 || this->Vy > 0) this->Vy = 0;
				}


// ------------ splash effect
				if (!HasSplashed)
				{
					if (RodIsCast)
					{
						if (Screen->ComboT[ComboAt(this->X+7,this->Y+14)] == CT_WATER)
						{
							if (this->X < Link->X - 40)
							{
								Game->PlaySound(SFX_SPLASH);
								HasSplashed = true;
								if (SplashSprite != 0)
								{
									lweapon Sploooosh = CreateLWeaponAt(LW_SPARKLE,this->X,this->Y+8);
									Sploooosh->UseSprite(SplashSprite);
								}
							}
						}
					}
				}
				else if (HasSplashed)
				{
					if (!RodIsCast) HasSplashed = false; 
				}
				




// ------------ Catching items
				for(FFCForTimer = Screen->NumItems(); FFCForTimer > 0; FFCForTimer--)
				{
					FFCRandoItem = Screen->LoadItem(FFCForTimer);
					if(!FFCRandoItem->isValid()) continue;
					{
						if (Collision(this,FFCRandoItem))
						{
							if (!ItemIsHooked){
								if (this->X > FFCRandoItem->X-2 && this->X < FFCRandoItem->X+2 && this->Y > FFCRandoItem->Y - 4 && this->Y < FFCRandoItem->Y + 4)
								{
									if (FirstItemX == 0) FirstItemX = FFCRandoItem->X;
									if (FirstItemY == 0) FirstItemY = FFCRandoItem->Y;
									Game->PlaySound(SFX_MSG);
									HookedItem = Screen->LoadItem(FFCForTimer);
									ItemIsHooked = true;
								}
							}
						}
						else if (CanWalk(FFCRandoItem->X,FFCRandoItem->Y,DIR_DOWN,1,false)) FFCRandoItem->Y ++;
					}
				}
				if (HookedItem->isValid())
				{
					if (Collision(this,HookedItem) && ItemIsHooked)
					{
						HookedItem->X = this->X;
						HookedItem->Y = this->Y;
					}
				}
				else if (ItemIsHooked) ItemIsHooked = false;


// ------------ Bonus items
				if (StopPrizes > 0)
				{
					if (Screen->State[ST_ITEM] && BonusPrize1 >= 0)
					{
						if (Screen->NumItems() == 0)
						{
							BonusRupy = CreateItemAt(Choose(I_RUPEE1,I_RUPEE1,I_RUPEE5,I_HEART,Choose(I_RUPEE1,I_RUPEE5,I_RUPEE5,BonusPrize1,BonusPrize1,BonusPrize2)),Rand(12)*16,Rand(2,8)*16);
							StopPrizes --;
						}
						if (BonusRupy->isValid())
						{
							if (SetLocation >0 && !PositionSet)
							{
								BonusRupy->X = ComboX(SetLocation);
								BonusRupy->Y = ComboY(SetLocation);
								PositionSet = true;
							}
							else if (Screen->ComboS[ComboAt(BonusRupy->X+7,BonusRupy->Y+12)] != 0)
							{
								BonusRupy->X = Rand(12)*16;
								BonusRupy->Y = Rand(2,8)*16;
							}
						}
					}
				}
			

// ------------ Enemies break the line

				for(FFCForTimer = Screen->NumNPCs(); FFCForTimer > 0; FFCForTimer--)
				{
					FFCRandoNPC = Screen->LoadNPC(FFCForTimer);
					if(!FFCRandoNPC->isValid()) continue;
					{
						if (Collision(this,FFCRandoNPC) && FFCRandoNPC->Stun == 0)
						{
							FFCRandoNPC->Stun = 255;
							Game->PlaySound(SFX_EHIT);
							this->X = Link->X-8;
							this->Y = Link->Y+8;
							RodIsCast = false;
							ItemIsHooked = false;
						}
					}
				}


// ------------ EWeapons break the line

				for(FFCForTimer = Screen->NumEWeapons(); FFCForTimer > 0; FFCForTimer--)
				{
					FFCRandoEW = Screen->LoadEWeapon(FFCForTimer);
					if(!FFCRandoEW->isValid()) continue;
					{
						if (Collision(this,FFCRandoEW))
						{
							if (FFCRandoEW->ID == EW_ARROW) FFCRandoEW->DeadState = WDS_ARROW;
							else FFCRandoEW->DeadState = WDS_DEAD;
							Game->PlaySound(SFX_CLINK);
							this->X = Link->X-8;
							this->Y = Link->Y+8;
							RodIsCast = false;
							ItemIsHooked = false;
						}
					}
				}

// ------------ Hook falling offscreen breaks the line, and B cancels hook
				if (this->Y > 170 || Link->PressB)
				{
					Game->PlaySound(SFX_MSG);
					this->X = Link->X-8;
					this->Y = Link->Y+8;
					RodIsCast = false;
					ItemIsHooked = false;
				}




// ------------ Link animations that had to be at the end
				NoAction();
				if (NoRepeatA) Link->InputLeft = true;
			}

		}
	}
}

// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
// FFC script: Fishing (end)
// --------------------------------------------------------------------------
// --------------------------------------------------------------------------





// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
// FFC script: Title Screen / Menu Screen (Start) UNFINISHED
// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
// This FFC script hasn't been rewritten in a while, and refers to items that were dummied out and is set up to show an incomplete early version of the mode menu.
// So it needs a rewrite. Probably should remember how to do that array of strings thing, too, like the LaZPoC scroling credits, I forgot that when I was starting to write this.

ffc script TitleMenuScreens
{
	void run(int MenuOrTitle, int MenuDraw, int TitleDraw)
	{
// D0 - if 0, the mode info screen. If 1, the intro screen.
// D1 - Screen number (of same map) to draw for mode info screen.
// D2 - Screen number (of same map) to draw for the intro scroll. Uses # screens in a row.



		int MODEMENU_1[32]="- M O D E   B U T T O N S -";
		int MODEMENU_2[8]=" HARD ";
		int MODEMENU_3[24]="EX1 - NO HEART DROPS";
		int MODEMENU_4[24]="EX2 - STRONGER MONSTERS";
		int MODEMENU_5[8]=" EASY ";
		int MODEMENU_6[24]="EX3 - AUTO FILL LIFE";
		int MODEMENU_7[24]="EX4 - MODERN EASY WALK";
		int MODEMENU_8[24]="PRESS START";



		int INTROSCROLL_1[32]=" THE LEGEND CONTINUES ";

		int INTROSCROLL_2[32]="SHORT  TIME  AGO   HERO";

		int INTROSCROLL_3A[32]="      DEFEATED  PRINCE";
		int INTROSCROLL_3B[32]="LINK";

		int INTROSCROLL_4A[32]="DARKNESS            WITH";
		int INTROSCROLL_4B[32]="         ' GANNON '     ";

		int INTROSCROLL_5A[32]="           AND   RESCUED";
		int INTROSCROLL_5B[32]="TRIFORCE                ";

		int INTROSCROLL_6A[32]="PRINCESS            BUT";
		int INTROSCROLL_6B[32]="         ' ZELDA '      ";

		int INTROSCROLL_7A[32]="                 APPEARS";
		int INTROSCROLL_7B[32]="' MIRROR GANNON '       ";

		int INTROSCROLL_8[32]="FROM  POWER  TO  SHATTER";

		int INTROSCROLL_9A[32]="' 8 '        MIRRORFORCE";
		int INTROSCROLL_9B[32]="     UNITS              ";

		int INTROSCROLL_10[32]="TO CAPTURE HIM.";

		int INTROSCROLL_11[32]="GO FIND THE ' 8 'UNITS  ";

		int INTROSCROLL_12A[32]="          TO SAVE HIM.";
		int INTROSCROLL_12B[32]="' ZELDA '             ";

		int INTROSCROLL_13[32]=" ALL OF TREASURES ";



		int INTROSCROLL_14[32]=" ALL OF TREASURES ";
		int INTROSCROLL_15[32]="                         ";
		int INTROSCROLL_16[32]="HEART               HALF ";
		int INTROSCROLL_17[32]="                CONTAINER";

		int INTROSCROLL_18[32]="   FAIRY          RUPOOR ";

		int INTROSCROLL_19[32]="RUPY             5 RUPIES";

		int INTROSCROLL_20[32]=" SECRET          GUARDIAN";
		int INTROSCROLL_21[32]="MEDICINE          ACORN  ";

		int INTROSCROLL_22[32]="LETTERS            GOOD  ";
		int INTROSCROLL_23[32]="                 OCTOROK ";

		int INTROSCROLL_24[32]="CANE               BLUE  ";
		int INTROSCROLL_25[32]="                   CANE  ";

		int INTROSCROLL_26[32]="MAGICAL           HIDING ";
		int INTROSCROLL_27[32]="CANE              SHELL  ";

		int INTROSCROLL_28[32]=" BEETLE           STRONG ";
		int INTROSCROLL_29[32]="                  BEETLE ";

		int INTROSCROLL_30[32]=" BOLA             POWER  ";
		int INTROSCROLL_31[32]="                  BOLA   ";

		int INTROSCROLL_32[32]=" IRON             GOLDEN ";
		int INTROSCROLL_33[32]=" BOOTS            BOOTS  ";

		int INTROSCROLL_34[32]="PEGASUS           MAGNET ";
		int INTROSCROLL_35[32]=" BOOTS                   ";

		int INTROSCROLL_36[32]="SHOVEL            BOW-WOW";

		int INTROSCROLL_37[32]=" BLUE              RED   ";
		int INTROSCROLL_38[32]="LADDER            LADDER ";

		int INTROSCROLL_39[32]="LANTERN           FISHING";
		int INTROSCROLL_40[32]="                    ROD  ";

		int INTROSCROLL_41[32]="  WHISP            DUCK  ";
		int INTROSCROLL_42[32]="  RING                   ";

		int INTROSCROLL_43[32]="  GIBO             KEY   ";
		int INTROSCROLL_44[32]="                         ";

		int INTROSCROLL_45[32]="  MAP            BIG KEY ";

		int INTROSCROLL_46[32]="       MIRRORFORCE       ";



		Waitframe();
		DoDraw = false;


		while(true)
		{
			Waitframe();

			if (MenuOrTitle == 0)
			{


				Screen->DrawScreen(6,Game->GetCurMap(),MenuDraw,0,0,0);
				

				Screen->DrawString(7, 104, 0, FONT_Z1, 147, 0, TF_NORMAL, MODEMENU_2, OP_OPAQUE);
				Screen->DrawString(7, 44, 12, FONT_Z1, 1, 0, TF_NORMAL, MODEMENU_3, OP_OPAQUE);
				Screen->DrawString(7, 44, 28, FONT_Z1, 1, 0, TF_NORMAL, MODEMENU_4, OP_OPAQUE);

				Screen->DrawString(7, 104, 64, FONT_Z1, 3, 0, TF_NORMAL, MODEMENU_5, OP_OPAQUE);
				Screen->DrawString(7, 44, 76, FONT_Z1, 1, 0, TF_NORMAL, MODEMENU_6, OP_OPAQUE);
				Screen->DrawString(7, 44, 92, FONT_Z1, 1, 0, TF_NORMAL, MODEMENU_7, OP_OPAQUE);

				Screen->DrawString(7, 80, 144, FONT_Z1, 1, 0, TF_NORMAL, MODEMENU_8, OP_OPAQUE);




				if (Link->PressStart)
				{
					DoDraw = true;
					Link->X = 256;
				}
			}
		}
	}
}


// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
// FFC script: Title Screen / Menu Screen (End)
// --------------------------------------------------------------------------
// --------------------------------------------------------------------------

